<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>投掷3D轨迹分析 </title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&family=Orbitron:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            overflow: hidden;
        }
        
        body {
            font-family: 'Noto Sans SC', sans-serif;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 50%, #f1f5f9 100%);
            color: #1e293b;
        }
        
        .container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        
        /* 左侧3D视图 */
        .viewer-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            min-width: 0;
            overflow: hidden;
        }
        
        .viewer-header {
            padding: 15px 20px;
            background: linear-gradient(90deg, rgba(59,130,246,0.08) 0%, transparent 100%);
            border-bottom: 1px solid rgba(59,130,246,0.2);
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .viewer-header-left {
            flex: 1;
        }
        
        .viewer-header h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2em;
            color: #2563eb;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        
        .viewer-header .subtitle {
            font-size: 0.8em;
            color: #64748b;
            margin-top: 3px;
        }
        
        .import-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            border: none;
            color: #ffffff;
            font-family: 'Noto Sans SC', sans-serif;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .import-btn:hover {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
            transform: translateY(-1px);
        }
        
        .import-btn .icon {
            font-size: 1.1em;
        }
        
        .clear-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            border: none;
            color: #ffffff;
            font-family: 'Noto Sans SC', sans-serif;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .clear-btn:hover {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
            transform: translateY(-1px);
        }
        
        .clear-icon {
            font-size: 1.1em;
        }
        
        /* 导入弹窗 */
        .import-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        
        .import-modal.show {
            display: flex;
        }
        
        .import-modal-content {
            background: #ffffff;
            border-radius: 16px;
            padding: 30px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        .import-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .import-modal-header h3 {
            font-size: 1.3em;
            color: #1e293b;
        }
        
        .import-modal-close {
            width: 32px;
            height: 32px;
            border: none;
            background: #f1f5f9;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2em;
            color: #64748b;
            transition: all 0.2s;
        }
        
        .import-modal-close:hover {
            background: #e2e8f0;
            color: #1e293b;
        }
        
        .import-drop-zone {
            border: 2px dashed #cbd5e1;
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8fafc;
            margin-bottom: 20px;
        }
        
        .import-drop-zone:hover,
        .import-drop-zone.dragover {
            border-color: #3b82f6;
            background: rgba(59,130,246,0.05);
        }
        
        .import-drop-zone .drop-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }
        
        .import-drop-zone .drop-text {
            font-size: 1em;
            color: #64748b;
            margin-bottom: 8px;
        }
        
        .import-drop-zone .drop-hint {
            font-size: 0.8em;
            color: #94a3b8;
        }
        
        .import-file-selected {
            display: none;
            background: #f0fdf4;
            border: 1px solid #86efac;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .import-file-selected.show {
            display: block;
        }
        
        .selected-file-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .file-icon {
            font-size: 2em;
        }
        
        .file-details {
            flex: 1;
        }
        
        .file-name {
            font-size: 0.95em;
            color: #166534;
            font-weight: 500;
        }
        
        .file-size {
            font-size: 0.8em;
            color: #15803d;
        }
        
        .remove-file-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: #fecaca;
            border-radius: 6px;
            cursor: pointer;
            color: #dc2626;
            font-size: 1em;
            transition: all 0.2s;
        }
        
        .remove-file-btn:hover {
            background: #fca5a5;
        }
        
        .import-info {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 8px;
            padding: 12px 15px;
            margin-bottom: 20px;
        }
        
        .import-info-title {
            font-size: 0.85em;
            color: #0369a1;
            font-weight: 500;
            margin-bottom: 5px;
        }
        
        .import-info-text {
            font-size: 0.8em;
            color: #0c4a6e;
            line-height: 1.5;
        }
        
        .progress-bar-container {
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .progress-text {
            font-size: 0.85em;
            color: #64748b;
            text-align: center;
        }
        
        .import-dropzone {
            border: 2px dashed #cbd5e1;
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 20px;
        }
        
        .import-dropzone:hover,
        .import-dropzone.dragover {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.05);
        }
        
        .import-dropzone .icon {
            font-size: 3em;
            margin-bottom: 15px;
        }
        
        .import-dropzone .text {
            color: #64748b;
            font-size: 0.95em;
        }
        
        .import-dropzone .hint {
            color: #94a3b8;
            font-size: 0.8em;
            margin-top: 8px;
        }
        
        .import-file-input {
            display: none;
        }
        
        .import-selected-file {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px 15px;
            margin-bottom: 20px;
            display: none;
        }
        
        .import-selected-file.show {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .import-selected-file .file-icon {
            font-size: 1.5em;
        }
        
        .import-selected-file .file-info {
            flex: 1;
        }
        
        .import-selected-file .file-name {
            font-weight: 500;
            color: #1e293b;
        }
        
        .import-selected-file .file-size {
            font-size: 0.8em;
            color: #64748b;
        }
        
        .import-selected-file .remove-file {
            border: none;
            background: transparent;
            color: #ef4444;
            cursor: pointer;
            font-size: 1.2em;
        }
        
        .import-athlete-input {
            margin-bottom: 20px;
        }
        
        .import-athlete-input label {
            display: block;
            font-size: 0.85em;
            color: #64748b;
            margin-bottom: 6px;
        }
        
        .import-athlete-input input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            font-size: 0.95em;
            transition: border-color 0.2s;
        }
        
        .import-athlete-input input:focus {
            outline: none;
            border-color: #3b82f6;
        }
        
        .import-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .import-actions button {
            padding: 10px 24px;
            border-radius: 8px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .import-cancel-btn {
            border: 1px solid #e2e8f0;
            background: #ffffff;
            color: #64748b;
        }
        
        .import-cancel-btn:hover {
            background: #f8fafc;
        }
        
        .import-confirm-btn {
            border: none;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: #ffffff;
        }
        
        .import-confirm-btn:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
        }
        
        .import-confirm-btn:disabled {
            background: #cbd5e1;
            cursor: not-allowed;
        }
        
        .import-progress {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .import-progress.show {
            display: block;
        }
        
        .import-progress .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #e2e8f0;
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        .import-progress .status {
            color: #64748b;
        }
        
        /* 数据预览区域 */
        .import-preview {
            display: none;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .import-preview.show {
            display: block;
        }
        
        .import-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .import-preview-title {
            font-weight: 600;
            color: #1e293b;
            font-size: 0.95em;
        }
        
        .import-preview-stats {
            font-size: 0.8em;
            color: #64748b;
        }
        
        .preview-field-group {
            margin-bottom: 12px;
        }
        
        .preview-field-name {
            font-size: 0.85em;
            font-weight: 500;
            color: #3b82f6;
            margin-bottom: 4px;
        }
        
        .preview-field-values {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.75em;
            color: #475569;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 8px 10px;
            overflow-x: auto;
            white-space: nowrap;
        }
        
        .preview-field-values.error {
            background: #fef2f2;
            border-color: #fecaca;
            color: #dc2626;
        }
        
        .preview-field-values.warning {
            background: #fffbeb;
            border-color: #fde68a;
            color: #d97706;
        }
        
        .preview-field-values.success {
            background: #f0fdf4;
            border-color: #bbf7d0;
            color: #16a34a;
        }
        
        .preview-separator {
            border-top: 1px dashed #cbd5e1;
            margin: 12px 0;
        }
        
        .preview-section-title {
            font-size: 0.8em;
            font-weight: 600;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }
        
        .preview-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 0.85em;
            margin-top: 10px;
        }
        
        .preview-status.valid {
            background: #f0fdf4;
            border: 1px solid #86efac;
            color: #16a34a;
        }
        
        .preview-status.invalid {
            background: #fef2f2;
            border: 1px solid #fecaca;
            color: #dc2626;
        }
        
        .preview-status.warning {
            background: #fffbeb;
            border: 1px solid #fde68a;
            color: #d97706;
        }
        
        .preview-status-icon {
            font-size: 1.1em;
        }
        
        .preview-skeleton-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            font-size: 0.75em;
            max-height: 200px;
            overflow-y: auto;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 8px;
        }
        
        .skeleton-joint-item {
            padding: 4px 6px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .skeleton-joint-item.found {
            background: #f0fdf4;
            color: #16a34a;
        }
        
        .skeleton-joint-item.missing {
            background: #fef2f2;
            color: #dc2626;
        }
        
        .skeleton-joint-item .joint-icon {
            flex-shrink: 0;
        }
        
        .skeleton-joint-item .joint-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .skeleton-joint-item .joint-col {
            font-size: 0.85em;
            opacity: 0.7;
        }
        
        /* 数据组选择器样式 */
        .data-group-selector {
            background: #fef3c7;
            border: 1px solid #fcd34d;
            border-radius: 8px;
            padding: 12px;
            margin-top: 10px;
        }
        
        .data-group-selector .selector-title {
            font-weight: 600;
            color: #92400e;
            margin-bottom: 10px;
            font-size: 0.85em;
        }
        
        .data-group-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .data-group-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .data-group-option:hover {
            border-color: #3b82f6;
        }
        
        .data-group-option.selected {
            border-color: #3b82f6;
            background: #eff6ff;
        }
        
        .data-group-option.recommended {
            border-color: #22c55e;
        }
        
        .data-group-option.recommended.selected {
            background: #f0fdf4;
        }
        
        .data-group-option .group-info {
            flex: 1;
        }
        
        .data-group-option .group-name {
            font-weight: 600;
            font-size: 0.85em;
        }
        
        .data-group-option .group-details {
            font-size: 0.75em;
            color: #6b7280;
        }
        
        .data-group-option .group-badge {
            font-size: 0.7em;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
        }
        
        .data-group-option .group-badge.recommended {
            background: #dcfce7;
            color: #16a34a;
        }
        
        .data-group-option .group-badge.warning {
            background: #fef3c7;
            color: #d97706;
        }
        
        .data-group-option .group-badge.error {
            background: #fee2e2;
            color: #dc2626;
        }
        
        /* 骨架预览区域样式 */
        .skeleton-preview-section {
            margin-top: 10px;
            padding: 12px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
        }
        
        .skeleton-preview-container {
            display: flex;
            gap: 15px;
            align-items: flex-start;
        }
        
        #skeleton-preview-canvas {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            flex-shrink: 0;
        }
        
        .skeleton-metrics {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .metric-item {
            background: white;
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }
        
        .metric-label {
            font-size: 0.7em;
            color: #6b7280;
            display: block;
        }
        
        .metric-value {
            font-size: 0.85em;
            font-weight: 600;
            color: #1f2937;
        }
        
        .metric-value.normal {
            color: #16a34a;
        }
        
        .metric-value.warning {
            color: #d97706;
        }
        
        .metric-value.error {
            color: #dc2626;
        }
        
        /* 数据质量评分样式 */
        .quality-score {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }
        
        .score-label {
            font-size: 0.8em;
            color: #6b7280;
        }
        
        .score-value {
            font-size: 0.9em;
            font-weight: 700;
            min-width: 50px;
        }
        
        .score-value.excellent {
            color: #16a34a;
        }
        
        .score-value.good {
            color: #65a30d;
        }
        
        .score-value.warning {
            color: #d97706;
        }
        
        .score-value.error {
            color: #dc2626;
        }
        
        .score-bar {
            flex: 1;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .score-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s, background 0.3s;
        }
        
        .score-fill.excellent {
            background: #22c55e;
        }
        
        .score-fill.good {
            background: #84cc16;
        }
        
        .score-fill.warning {
            background: #f59e0b;
        }
        
        .score-fill.error {
            background: #ef4444;
        }
        
        #canvas-container {
            flex: 1;
            position: relative;
            background: radial-gradient(ellipse at center, #ffffff 0%, #f1f5f9 100%);
            min-height: 300px;
        }
        
        #three-canvas {
            display: block;
        }
        
        /* 视图控制按钮 */
        .view-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        .view-btn {
            padding: 10px 20px;
            background: #ffffff;
            border: 1px solid #cbd5e1;
            color: #475569;
            font-family: 'Noto Sans SC', sans-serif;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .view-btn:hover {
            background: #f8fafc;
            border-color: #3b82f6;
            color: #3b82f6;
        }
        
        .view-btn.active {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border-color: #3b82f6;
            color: #ffffff;
            box-shadow: 0 4px 12px rgba(59,130,246,0.4);
        }
        
        /* 颜色图例 */
        .color-legend {
            position: absolute;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 100;
        }
        
        .color-bar {
            width: 20px;
            height: 200px;
            background: linear-gradient(to top, #3b82f6, #8b5cf6, #d946ef, #f43f5e, #f97316);
            border-radius: 6px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .legend-label {
            font-size: 0.75em;
            color: #64748b;
            margin: 8px 0;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-title {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
            font-size: 0.8em;
            color: #3b82f6;
            margin-left: 10px;
            letter-spacing: 2px;
            font-weight: 500;
        }
        
        /* 释放点标记说明 */
        .release-legend {
            position: absolute;
            top: 20px;
            right: 80px;
            background: #ffffff;
            padding: 12px 18px;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        
        .release-legend .icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            color: #f97316;
            margin-right: 8px;
            font-size: 16px;
        }
        
        .release-legend .text {
            font-size: 0.85em;
            color: #475569;
        }
        
        .release-legend .speed {
            color: #f97316;
            font-weight: 600;
        }
        
        /* 右侧数据面板 - 三列布局 */
        .data-panel {
            width: 720px;
            min-width: 140px;
            max-width: 900px;
            background: linear-gradient(180deg, #ffffff 0%, #f8fafc 100%);
            border-left: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            padding: 0;
            box-shadow: -4px 0 20px rgba(0,0,0,0.05);
            overflow: hidden;
            transition: width 0.3s ease, min-width 0.3s ease;
        }
        
        /* 所有列都折叠时的面板样式 */
        .data-panel.all-collapsed {
            width: auto;
            min-width: auto;
        }
        
        .data-panel.all-collapsed .panel-footer {
            display: none;
        }
        
        .panel-header {
            padding: 15px 20px;
            background: linear-gradient(90deg, transparent 0%, rgba(59,130,246,0.05) 100%);
            border-bottom: 1px solid #e2e8f0;
            flex-shrink: 0;
        }
        
        .panel-header h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1em;
            color: #2563eb;
            letter-spacing: 1.5px;
        }
        
        .athlete-info {
            margin-top: 10px;
            display: flex;
            gap: 15px;
        }
        
        .athlete-info .item {
            display: flex;
            flex-direction: column;
        }
        
        .athlete-info .label {
            font-size: 0.65em;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .athlete-info .value {
            font-size: 0.95em;
            color: #1e293b;
            margin-top: 2px;
            font-weight: 500;
        }
        
        .metrics-section {
            flex: 1;
            padding: 15px 20px;
            overflow-y: auto;
            min-height: 0;
        }
        
        .metrics-group {
            margin-bottom: 15px;
        }
        
        .metrics-group h3 {
            font-size: 0.7em;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .metric-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid #f1f5f9;
        }
        
        .metric-item .name {
            font-size: 0.8em;
            color: #64748b;
        }
        
        .metric-item .value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1em;
            color: #1e293b;
        }
        
        .metric-item .unit {
            font-size: 0.7em;
            color: #94a3b8;
            margin-left: 3px;
        }
        
        .metric-item.highlight .value {
            color: #f97316;
            font-size: 1.2em;
        }
        
        /* 关键指标卡片样式 */
        .key-metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .key-metric-card {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 12px;
            text-align: center;
        }
        
        .key-metric-card.primary {
            grid-column: span 2;
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-color: #fbbf24;
        }
        
        .key-metric-card .label {
            font-size: 0.65em;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }
        
        .key-metric-card .value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.4em;
            color: #1e293b;
        }
        
        .key-metric-card .unit {
            font-size: 0.7em;
            color: #64748b;
        }
        
        .key-metric-card.primary .value {
            font-size: 1.8em;
            color: #b45309;
        }
        
        /* 进度条样式 */
        .metric-bar {
            margin-top: 8px;
            height: 4px;
            background: #e2e8f0;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .metric-bar .fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            border-radius: 2px;
            transition: width 0.5s ease;
        }
        
        /* 可折叠区域样式 */
        .collapsible-section {
            border-bottom: 1px solid #e2e8f0;
        }
        
        .collapsible-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            cursor: pointer;
            user-select: none;
            transition: background 0.2s;
        }
        
        .collapsible-header:hover {
            background: #f8fafc;
        }
        
        .collapsible-toggle {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: #f1f5f9;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            color: #64748b;
        }
        
        .collapsible-toggle:hover {
            background: #e2e8f0;
            color: #334155;
        }
        
        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            max-height: 1000px;
        }
        
        .collapsible-section.collapsed .collapsible-content {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
        }
        
        .collapsible-section.collapsed .collapsible-toggle {
            transform: rotate(-90deg);
        }
        
        .collapsible-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: #334155;
            font-size: 0.9em;
        }
        
        /* 技术阶段面板 */
        .phase-section {
            padding: 0;
        }
        
        .phase-section .collapsible-content {
            padding: 0 20px 15px;
        }
        
        .phase-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .phase-title {
            font-size: 0.85em;
            font-weight: 600;
            color: #1e293b;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .phase-actions {
            display: flex;
            gap: 6px;
        }
        
        .phase-btn {
            padding: 5px 10px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            background: #ffffff;
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .phase-btn:hover {
            background: #f1f5f9;
            border-color: #cbd5e1;
        }
        
        .phase-btn.primary {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }
        
        .phase-btn.primary:hover {
            background: #2563eb;
        }
        
        .phase-btn.danger {
            color: #ef4444;
        }
        
        .phase-btn.danger:hover {
            background: #fef2f2;
        }
        
        /* 阶段选择初始状态 */
        .phase-initial {
            text-align: center;
            padding: 15px;
            background: #f8fafc;
            border-radius: 10px;
            border: 1px dashed #e2e8f0;
        }
        
        .phase-initial-text {
            font-size: 0.8em;
            color: #64748b;
            margin-bottom: 12px;
        }
        
        .phase-initial-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        
        .phase-mode-btn {
            padding: 10px 16px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: #ffffff;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            min-width: 100px;
        }
        
        .phase-mode-btn:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
        }
        
        .phase-mode-btn .icon {
            font-size: 1.5em;
        }
        
        .phase-mode-btn .label {
            font-weight: 500;
            color: #1e293b;
        }
        
        .phase-mode-btn .desc {
            font-size: 0.7em;
            color: #94a3b8;
        }
        
        /* 阶段列表 */
        .phase-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .phase-item {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .phase-item:hover {
            background: #f8fafc;
            border-color: #cbd5e1;
        }
        
        .phase-item.active {
            border-color: #3b82f6;
            background: #f0f9ff;
        }
        
        .phase-color {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            flex-shrink: 0;
        }
        
        .phase-info {
            flex: 1;
            min-width: 0;
        }
        
        .phase-name {
            font-size: 0.8em;
            font-weight: 500;
            color: #1e293b;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .phase-name-en {
            font-size: 0.7em;
            color: #94a3b8;
            font-weight: 400;
        }
        
        .phase-time {
            font-size: 0.7em;
            color: #64748b;
            font-family: 'Orbitron', sans-serif;
        }
        
        .phase-duration {
            font-size: 0.65em;
            color: #94a3b8;
            background: #f1f5f9;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 6px;
        }
        
        .phase-item-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .phase-item:hover .phase-item-actions {
            opacity: 1;
        }
        
        .phase-item-btn {
            padding: 4px 6px;
            border: none;
            background: transparent;
            font-size: 0.7em;
            cursor: pointer;
            border-radius: 4px;
            color: #64748b;
        }
        
        .phase-item-btn:hover {
            background: #e2e8f0;
            color: #1e293b;
        }
        
        .phase-item-btn.delete:hover {
            background: #fee2e2;
            color: #ef4444;
        }
        
        /* 手动模式添加按钮 */
        .phase-add-btn {
            width: 100%;
            padding: 8px;
            border: 1px dashed #cbd5e1;
            border-radius: 8px;
            background: transparent;
            font-size: 0.75em;
            color: #64748b;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 6px;
        }
        
        .phase-add-btn:hover {
            border-color: #3b82f6;
            color: #3b82f6;
            background: #f0f9ff;
        }
        
        /* 阶段编辑对话框 */
        .phase-dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
        }
        
        .phase-dialog-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .phase-dialog {
            background: #ffffff;
            border-radius: 12px;
            padding: 20px;
            width: 320px;
            max-width: 90vw;
            box-shadow: 0 20px 40px rgba(0,0,0,0.15);
            transform: scale(0.95);
            transition: transform 0.2s;
        }
        
        .phase-dialog-overlay.active .phase-dialog {
            transform: scale(1);
        }
        
        .phase-dialog-title {
            font-size: 1em;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 15px;
        }
        
        .phase-dialog-field {
            margin-bottom: 12px;
        }
        
        .phase-dialog-field label {
            display: block;
            font-size: 0.75em;
            color: #64748b;
            margin-bottom: 5px;
        }
        
        .phase-dialog-field input,
        .phase-dialog-field select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 0.85em;
            transition: border-color 0.2s;
        }
        
        .phase-dialog-field input:focus,
        .phase-dialog-field select:focus {
            outline: none;
            border-color: #3b82f6;
        }
        
        .phase-dialog-colors {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .phase-color-option {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .phase-color-option:hover {
            transform: scale(1.1);
        }
        
        .phase-color-option.selected {
            border-color: #1e293b;
        }
        
        .phase-dialog-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 20px;
        }
        
        .phase-dialog-btn {
            padding: 8px 16px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .phase-dialog-btn.cancel {
            background: #ffffff;
            color: #64748b;
        }
        
        .phase-dialog-btn.cancel:hover {
            background: #f1f5f9;
        }
        
        .phase-dialog-btn.confirm {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }
        
        .phase-dialog-btn.confirm:hover {
            background: #2563eb;
        }
        
        /* 图表区域 - 标签页设计 */
        .chart-section {
            padding: 0;
            flex-shrink: 0;
        }
        
        .chart-section .collapsible-content {
            padding: 0 20px 20px;
        }
        
        .chart-tabs {
            display: flex;
            gap: 4px;
            background: #f1f5f9;
            padding: 4px;
            border-radius: 10px;
            margin-bottom: 12px;
        }
        
        .chart-tab {
            flex: 1;
            padding: 8px 12px;
            border: none;
            background: transparent;
            border-radius: 8px;
            font-size: 0.8em;
            font-weight: 500;
            color: #64748b;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .chart-tab:hover {
            color: #475569;
            background: rgba(255,255,255,0.5);
        }
        
        .chart-tab.active {
            background: white;
            color: #3b82f6;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        
        .chart-panels {
            background: #ffffff;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
        }
        
        .chart-panel {
            display: none;
            padding: 15px;
        }
        
        .chart-panel.active {
            display: block;
        }
        
        .chart-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .chart-value-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.75em;
            color: #3b82f6;
            background: #f8fafc;
            padding: 5px 12px;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }
        
        .chart-value-display span {
            font-weight: 600;
        }
        
        #chart-hover-speed, #joint-hover-speed {
            color: #f97316;
        }
        
        .chart-wrapper {
            display: flex;
            align-items: stretch;
            gap: 6px;
        }
        
        .y-axis-label {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
            font-size: 0.65em;
            color: #94a3b8;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 2px;
        }
        
        .chart-area {
            flex: 1;
            position: relative;
            height: 130px;
            background: linear-gradient(to bottom, rgba(59,130,246,0.02) 0%, rgba(249,115,22,0.02) 100%);
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
            cursor: crosshair;
        }
        
        #speed-chart, #com-chart, #joint-chart {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .chart-cursor {
            position: absolute;
            top: 0;
            width: 1px;
            height: 100%;
            background: #3b82f6;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s ease;
        }
        
        .chart-current-line {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: #22c55e;
            pointer-events: none;
            opacity: 0.8;
        }
        
        .x-axis-label {
            font-size: 0.65em;
            color: #94a3b8;
            text-align: center;
            margin-top: 6px;
            margin-left: 35px;
        }
        
        .chart-wrapper.dual-axis {
            display: flex;
            align-items: stretch;
        }
        
        .y-axis-label.right-axis {
            transform: rotate(180deg);
            writing-mode: vertical-rl;
        }
        
        .chart-legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 8px;
            font-size: 0.7em;
            color: #64748b;
        }
        
        .chart-legend .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .chart-legend .legend-color {
            width: 12px;
            height: 3px;
            border-radius: 2px;
        }
        
        /* 关节选择器样式 */
        .joint-selector-wrapper {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .joint-selector {
            padding: 4px 8px;
            border: 1px solid #e2e8f0;
            border-radius: 5px;
            font-size: 0.75em;
            max-width: 140px;
            color: #475569;
            background: white;
            cursor: pointer;
            min-width: 140px;
        }
        
        .joint-selector:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59,130,246,0.2);
        }
        
        .add-joint-btn {
            width: 28px;
            height: 28px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            background: #f8fafc;
            color: #64748b;
            font-size: 1.2em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .add-joint-btn:hover {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }
        
        .selected-joints {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 10px 0;
            min-height: 28px;
        }
        
        .joint-tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.75em;
            color: white;
            cursor: default;
        }
        
        .joint-tag .remove-btn {
            width: 14px;
            height: 14px;
            border: none;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            color: white;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .joint-tag .remove-btn:hover {
            background: rgba(255,255,255,0.5);
        }
        
        .joint-tag .color-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }
        
        /* 三列布局容器 */
        .panel-columns {
            display: flex;
            flex: 1;
            overflow: hidden;
            justify-content: flex-end;  /* 折叠时靠右对齐 */
        }
        
        .panel-column {
            flex: 1;
            min-width: 0;
            overflow-y: auto;
            border-right: 1px solid #e2e8f0;
        }
        
        .panel-column:last-child {
            border-right: none;
        }
        
        .panel-column-header {
            padding: 12px 15px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            font-weight: 600;
            font-size: 0.85em;
            color: #334155;
            display: flex;
            align-items: center;
            gap: 6px;
            position: sticky;
            top: 0;
            z-index: 5;
        }
        
        .panel-column-header .athlete-info {
            margin-left: auto;
            font-size: 0.85em;
            font-weight: 400;
            color: #64748b;
        }
        
        .collapsible-column.collapsed .panel-column-header .athlete-info {
            display: none;
        }
        
        .panel-column-content {
            padding: 10px;
        }
        
        /* 紧凑版关键指标 */
        .key-metrics.compact {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            padding: 0;
        }
        
        .key-metrics.compact .key-metric-card {
            padding: 10px;
        }
        
        .key-metrics.compact .key-metric-card .value {
            font-size: 1.4em;
        }
        
        .key-metrics.compact .key-metric-card.primary {
            grid-column: 1 / -1;
        }
        
        .key-metrics.compact .key-metric-card.primary .value {
            font-size: 2em;
        }
        
        /* 紧凑版详细参数 */
        .metrics-group.compact {
            padding: 10px 0;
        }
        
        .metrics-group.compact h3 {
            font-size: 0.75em;
            margin-bottom: 6px;
        }
        
        .metrics-group.compact .metric-item {
            padding: 4px 0;
            font-size: 0.85em;
        }
        
        /* 图表列样式 */
        .chart-column-content {
            padding: 8px !important;
        }
        
        .chart-tabs.compact {
            padding: 3px;
            gap: 2px;
            margin-bottom: 8px;
        }
        
        .chart-tabs.compact .chart-tab {
            padding: 6px 10px;
            font-size: 0.75em;
        }
        
        /* 阶段列样式 */
        .phase-column-content {
            padding: 8px !important;
        }
        
        .phase-column-content .phase-initial {
            padding: 10px;
        }
        
        .phase-column-content .phase-initial-text {
            font-size: 0.8em;
            margin-bottom: 10px;
        }
        
        .phase-column-content .phase-initial-buttons {
            flex-direction: column;
            gap: 8px;
        }
        
        .phase-column-content .phase-mode-btn {
            padding: 12px 10px;
        }
        
        .phase-column-content .phase-mode-btn .label {
            font-size: 0.85em;
        }
        
        .phase-column-content .phase-mode-btn .desc {
            font-size: 0.65em;
        }
        
        .phase-column-content .phase-list {
            gap: 4px;
        }
        
        .phase-column-content .phase-item {
            padding: 8px 10px;
        }
        
        .phase-column-content .phase-item-name {
            font-size: 0.8em;
        }
        
        .phase-column-content .phase-item-time {
            font-size: 0.65em;
        }
        
        /* 重置按钮小版本 */
        .phase-btn.small {
            padding: 4px 8px;
            font-size: 0.7em;
        }
        
        /* 可折叠列样式 */
        .collapsible-column {
            transition: flex 0.3s ease, min-width 0.3s ease;
        }
        
        .collapsible-column .panel-column-header {
            cursor: pointer;
            user-select: none;
        }
        
        .collapsible-column .panel-column-header:hover {
            background: #eef2f7;
        }
        
        .column-toggle {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 10px;
            color: #64748b;
            margin-left: auto;
            transition: transform 0.3s;
            flex-shrink: 0;
        }
        
        .column-toggle:hover {
            color: #334155;
        }
        
        .collapsible-column.collapsed {
            flex: 0 0 40px !important;
            min-width: 40px !important;
        }
        
        .collapsible-column.collapsed .panel-column-header {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            padding: 15px 8px;
            justify-content: flex-start;
            gap: 8px;
            height: 100%;
        }
        
        .collapsible-column.collapsed .panel-column-header span:last-of-type {
            margin-top: 5px;
        }
        
        .collapsible-column.collapsed .column-toggle {
            transform: rotate(-90deg);
            margin-left: 0;
            margin-top: auto;
        }
        
        .collapsible-column.collapsed .panel-column-content {
            display: none;
        }
        
        .collapsible-column.collapsed .phase-actions {
            display: none !important;
        }
        
        /* 底部信息 */
        .panel-footer {
            padding: 12px 20px;
            background: #f8fafc;
            border-top: 1px solid #e2e8f0;
            flex-shrink: 0;
        }
        
        .footer-note {
            font-size: 0.7em;
            color: #94a3b8;
            text-align: center;
        }
        
        /* 图例说明 */
        .trajectory-legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8em;
            color: #64748b;
        }
        
        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        
        .legend-dot.discus {
            background: linear-gradient(45deg, #3b82f6, #f97316);
        }
        
        .legend-dot.com {
            background: #94a3b8;
            border: 1px dashed #64748b;
        }
        
        /* 加载动画 */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f8fafc;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }
        
        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid #e2e8f0;
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* 时间轴控制样式 */
        .timeline-control {
            position: relative;
            background: #ffffff;
            border-radius: 0;
            padding: 12px 20px;
            border-top: 1px solid #e2e8f0;
            flex-shrink: 0;
        }
        
        .timeline-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }
        
        .play-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border: none;
            color: white;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(59,130,246,0.4);
        }
        
        .play-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(59,130,246,0.5);
        }
        
        .play-btn.playing {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            box-shadow: 0 2px 8px rgba(249,115,22,0.4);
        }
        
        .time-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1em;
            color: #1e293b;
        }
        
        .timeline-slider-container {
            position: relative;
            margin-bottom: 10px;
        }
        
        #timeline-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #e2e8f0;
            border-radius: 4px;
            outline: none;
            cursor: pointer;
        }
        
        #timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(59,130,246,0.4);
            transition: transform 0.1s ease;
        }
        
        #timeline-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
        
        #timeline-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(59,130,246,0.4);
        }
        
        .timeline-markers {
            position: absolute;
            top: 12px;
            left: 0;
            right: 0;
            height: 10px;
            pointer-events: none;
        }
        
        .timeline-marker {
            position: absolute;
            width: 2px;
            height: 10px;
            background: #f97316;
            transform: translateX(-50%);
        }
        
        .timeline-marker::after {
            content: '释放点';
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7em;
            color: #f97316;
            white-space: nowrap;
        }
        
        .current-point-info {
            display: flex;
            gap: 10px;
            font-size: 0.8em;
            color: #64748b;
            flex-wrap: wrap;
            margin-left: auto;
        }
        
        .current-point-info span {
            display: inline-flex;
            align-items: center;
        }
        
        .current-point-info .cur-speed {
            color: #f97316;
            font-weight: 500;
        }
        
        .timeline-slider-container {
            margin-bottom: 0;
            position: relative;
            padding-top: 5px;
        }
        
        /* 切换按钮组 */
        .toggle-buttons {
            position: absolute;
            top: 70px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }
        
        .toggle-btn {
            padding: 8px 15px;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85em;
            color: #475569;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        
        .toggle-btn:hover {
            background: #f8fafc;
            border-color: #3b82f6;
            color: #3b82f6;
        }
        
        .toggle-btn.active {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border-color: #3b82f6;
            color: white;
            box-shadow: 0 2px 8px rgba(59,130,246,0.4);
        }
        
        #skeleton-btn.active {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            border-color: #22c55e;
            box-shadow: 0 2px 8px rgba(34,197,94,0.4);
        }
        
        #skeleton-btn:hover:not(.active) {
            border-color: #22c55e;
            color: #22c55e;
        }
        
        #range-trajectory-btn.active {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            border-color: #8b5cf6;
            box-shadow: 0 2px 8px rgba(139,92,246,0.4);
        }
        
        #range-trajectory-btn:hover:not(.active) {
            border-color: #8b5cf6;
            color: #8b5cf6;
        }
        
        .toggle-icon {
            font-size: 1.1em;
        }
        
        /* 跳高设备控制按钮组 */
        .circle-control-buttons {
            position: absolute;
            bottom: 80px;
            left: 20px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }
        
        .circle-btn {
            padding: 10px 16px;
            background: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9em;
            font-weight: 500;
            color: #475569;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .circle-btn:hover {
            background: #f8fafc;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .circle-btn.active {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            border-color: #f97316;
            color: white;
            box-shadow: 0 4px 12px rgba(249,115,22,0.4);
        }
        
        .circle-btn.save-btn {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            border-color: #22c55e;
            color: white;
        }
        
        .circle-btn.save-btn:hover {
            box-shadow: 0 4px 12px rgba(34,197,94,0.4);
        }
        
        .circle-btn.reset-btn {
            background: #f1f5f9;
            border-color: #cbd5e1;
            color: #64748b;
        }
        
        .circle-btn.reset-btn:hover {
            background: #e2e8f0;
        }
        
        /* 场地类型选择器 */
        .field-type-selector {
            display: flex;
            align-items: center;
        }
        
        .field-type-selector select {
            padding: 10px 16px;
            font-size: 14px;
            font-weight: 600;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            background: #ffffff;
            color: #475569;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23475569' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 36px;
        }
        
        .field-type-selector select:hover {
            background-color: #f8fafc;
            border-color: #3b82f6;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .field-type-selector select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59,130,246,0.2);
        }
        
        .btn-icon {
            font-size: 1.2em;
        }
        
        .circle-position-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255,255,255,0.95);
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 0.8em;
            color: #64748b;
            border: 1px solid #e2e8f0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            z-index: 100;
            display: none;
        }
        
        .circle-position-info.visible {
            display: block;
        }
        
        .circle-position-info span {
            font-family: 'Orbitron', sans-serif;
        }
        
        /* 播放控制扩展样式 */
        .playback-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .control-group label {
            font-size: 0.75em;
            color: #64748b;
            white-space: nowrap;
        }
        
        .control-group input[type="number"] {
            width: 60px;
            padding: 4px 8px;
            border: 1px solid #cbd5e1;
            border-radius: 4px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85em;
            color: #1e293b;
            background: white;
        }
        
        .control-group input[type="number"]:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59,130,246,0.2);
        }
        
        .loop-btn, .speed-btn {
            padding: 6px 12px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            color: #64748b;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s ease;
        }
        
        .loop-btn:hover, .speed-btn:hover {
            background: #f1f5f9;
            border-color: #3b82f6;
            color: #3b82f6;
        }
        
        .loop-btn.active {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            border-color: #8b5cf6;
            color: white;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .speed-control label {
            font-size: 0.75em;
            color: #64748b;
            white-space: nowrap;
        }
        
        .speed-slider {
            width: 80px;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #e2e8f0;
            border-radius: 3px;
            outline: none;
        }
        
        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .speed-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .speed-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85em;
            color: #8b5cf6;
            min-width: 40px;
            text-align: center;
        }
        
        .range-indicator {
            position: absolute;
            top: 6px;
            height: 8px;
            background: rgba(139, 92, 246, 0.3);
            border-radius: 4px;
            pointer-events: none;
        }
        
        .timeline-slider-container {
            position: relative;
        }
        
        /* 阶段颜色条 */
        .phase-color-bar {
            display: flex;
            height: 16px;
            margin-top: 6px;
            border-radius: 4px;
            overflow: hidden;
            background: #f1f5f9;
        }
        
        .phase-color-bar:empty {
            display: none;
        }
        
        .phase-color-segment {
            height: 100%;
            position: relative;
            cursor: pointer;
            transition: filter 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .phase-color-segment:hover {
            filter: brightness(1.1);
        }
        
        .phase-color-segment .phase-label {
            font-size: 10px;
            font-weight: 600;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            white-space: nowrap;
            overflow: visible;
            padding: 0 2px;
            letter-spacing: -0.5px;
        }
        
        .phase-color-segment::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1e293b;
            color: white;
            font-size: 0.65em;
            padding: 4px 8px;
            border-radius: 4px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
            pointer-events: none;
            margin-bottom: 4px;
        }
        
        .phase-color-segment:hover::after {
            opacity: 1;
            visibility: visible;
        }
        
        .range-markers {
            position: absolute;
            top: 5px;
            left: 0;
            right: 0;
            height: 20px;
            pointer-events: none;
            z-index: 5;
        }
        
        .range-start-marker, .range-end-marker {
            position: absolute;
            width: 12px;
            height: 20px;
            top: -6px;
            border-radius: 3px;
            transform: translateX(-50%);
            cursor: ew-resize;
            pointer-events: auto;
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            z-index: 10;
        }
        
        .range-start-marker:hover, .range-end-marker:hover {
            transform: translateX(-50%) scale(1.2);
        }
        
        .range-start-marker:active, .range-end-marker:active {
            transform: translateX(-50%) scale(1.1);
        }
        
        .range-start-marker {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            box-shadow: 0 2px 6px rgba(34, 197, 94, 0.4);
        }
        
        .range-start-marker:hover {
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.6);
        }
        
        .range-start-marker::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 10px;
            background: rgba(255,255,255,0.6);
            border-radius: 1px;
        }
        
        .range-end-marker {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            box-shadow: 0 2px 6px rgba(239, 68, 68, 0.4);
        }
        
        .range-end-marker:hover {
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.6);
        }
        
        .range-end-marker::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 10px;
            background: rgba(255,255,255,0.6);
            border-radius: 1px;
        }
        
        .range-start-marker.dragging, .range-end-marker.dragging {
            transform: translateX(-50%) scale(1.3);
            z-index: 20;
        }
        
        .range-tooltip {
            position: absolute;
            top: -28px;
            left: 50%;
            transform: translateX(-50%);
            background: #1e293b;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.7em;
            font-family: 'Orbitron', sans-serif;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.15s ease;
            pointer-events: none;
        }
        
        .range-tooltip::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 4px solid #1e293b;
        }
        
        .range-start-marker:hover .range-tooltip,
        .range-end-marker:hover .range-tooltip,
        .range-start-marker.dragging .range-tooltip,
        .range-end-marker.dragging .range-tooltip {
            opacity: 1;
        }
        
        /* 响应式 */
        @media (max-width: 1200px) {
            .container {
                flex-direction: column;
                height: auto;
                min-height: 100vh;
            }
            
            .viewer-section {
                min-height: 500px;
            }
            
            .data-panel {
                width: 100%;
                max-height: none;
            }
            
            .metrics-section {
                display: flex;
                flex-wrap: wrap;
                gap: 20px;
            }
            
            .metrics-group {
                flex: 1;
                min-width: 200px;
            }
            
            .current-point-info {
                margin-left: 0;
                margin-top: 5px;
                width: 100%;
            }
        }
        
        @media (max-width: 768px) {
            .viewer-header h1 {
                font-size: 1em;
            }
            
            .view-controls {
                flex-wrap: wrap;
                gap: 5px;
            }
            
            .view-btn {
                padding: 8px 12px;
                font-size: 0.75em;
            }
            
            .timeline-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .playback-controls {
                width: 100%;
            }
            
            .control-group {
                padding: 4px 8px;
            }
            
            .control-group input[type="number"] {
                width: 50px;
            }
            
            .speed-control {
                padding: 4px 8px;
            }
            
            .speed-slider {
                width: 60px;
            }
            
            .current-point-info {
                margin-left: 0;
            }
        }
        
        @media (max-width: 480px) {
            .playback-controls {
                gap: 8px;
            }
            
            .control-group label {
                display: none;
            }
            
            .speed-control label {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
    </div>
    
    <!-- 导入数据弹窗 -->
    <div class="import-modal" id="import-modal">
        <div class="import-modal-content">
            <div class="import-modal-header">
                <h3>导入动捕数据</h3>
                <button class="import-modal-close" id="import-modal-close">&times;</button>
            </div>
            
            <div class="import-drop-zone" id="import-drop-zone">
                <div class="drop-icon">📁</div>
                <div class="drop-text">点击选择或拖拽文件到此处</div>
                <div class="drop-hint">支持 all.txt 格式的动捕数据文件</div>
                <input type="file" id="file-input" accept=".txt" style="display: none;">
            </div>
            
            <div class="import-file-selected" id="import-file-selected">
                <div class="selected-file-info">
                    <span class="file-icon">📄</span>
                    <div class="file-details">
                        <div class="file-name" id="selected-file-name">--</div>
                        <div class="file-size" id="selected-file-size">--</div>
                    </div>
                    <button class="remove-file-btn" id="remove-file-btn">&times;</button>
                </div>
            </div>
            
            <!-- 数据预览区域 -->
            <div class="import-preview" id="import-preview">
                <div class="import-preview-header">
                    <span class="import-preview-title">📊 数据预览</span>
                    <span class="import-preview-stats" id="preview-stats">--</span>
                </div>
                
                <div class="preview-section-title">关键字段数据样本 (前5帧)</div>
                
                <div class="preview-field-group">
                    <div class="preview-field-name">⏱ 时间 (Time)</div>
                    <div class="preview-field-values" id="preview-time">--</div>
                </div>
                
                <div class="preview-field-group">
                    <div class="preview-field-name">🎯 重心位置 (CenterOfGravity X/Y/Z)</div>
                    <div class="preview-field-values" id="preview-cog">--</div>
                </div>
                
                <div class="preview-field-group">
                    <div class="preview-field-name">✋ 右手位置 (Hand_R X/Y/Z) - 铁饼轨迹</div>
                    <div class="preview-field-values" id="preview-hand">--</div>
                </div>
                
                <div class="preview-separator"></div>
                <div class="preview-section-title">自动字段检测 (自适应不同数据格式)</div>
                
                <div class="preview-field-group">
                    <div class="preview-field-name">📏 总列数</div>
                    <div class="preview-field-values" id="preview-cols">--</div>
                </div>
                
                <div class="preview-field-group">
                    <div class="preview-field-name">🎯 重心字段 (CenterOfGravity)</div>
                    <div class="preview-field-values" id="preview-cog-pos">--</div>
                </div>
                
                <div class="preview-field-group">
                    <div class="preview-field-name">✋ 右手/铁饼字段 (Hand/Index/Base/Right)</div>
                    <div class="preview-field-values" id="preview-hand-pos">--</div>
                </div>
                
                <div class="preview-field-group">
                    <div class="preview-field-name">🦴 骨架关节点 (27个)</div>
                    <div class="preview-skeleton-grid" id="preview-skeleton-list">
                        <!-- 关节列表将动态生成 -->
                    </div>
                </div>
                
                <!-- 数据组选择器（当检测到多组数据时显示） -->
                <div class="data-group-selector" id="data-group-selector" style="display: none;">
                    <div class="selector-title">⚠️ 检测到多组同名数据，请选择:</div>
                    <div class="data-group-options" id="data-group-options">
                        <!-- 数据组选项将动态生成 -->
                    </div>
                </div>
                
                <!-- 骨架预览和验证结果 -->
                <div class="skeleton-preview-section" id="skeleton-preview-section">
                    <div class="preview-section-title">📐 骨架数据验证</div>
                    <div class="skeleton-preview-container">
                        <canvas id="skeleton-preview-canvas" width="150" height="200"></canvas>
                        <div class="skeleton-metrics" id="skeleton-metrics">
                            <div class="metric-item">
                                <span class="metric-label">身高:</span>
                                <span class="metric-value" id="metric-height">--</span>
                            </div>
                            <div class="metric-item">
                                <span class="metric-label">肩宽:</span>
                                <span class="metric-value" id="metric-shoulder">--</span>
                            </div>
                            <div class="metric-item">
                                <span class="metric-label">臂长:</span>
                                <span class="metric-value" id="metric-arm">--</span>
                            </div>
                            <div class="metric-item">
                                <span class="metric-label">腿长:</span>
                                <span class="metric-value" id="metric-leg">--</span>
                            </div>
                        </div>
                    </div>
                    <div class="quality-score" id="quality-score">
                        <span class="score-label">数据质量:</span>
                        <span class="score-value" id="score-value">--</span>
                        <span class="score-bar"><span class="score-fill" id="score-fill"></span></span>
                    </div>
                </div>
                
                <div class="preview-status" id="preview-status">
                    <span class="preview-status-icon" id="preview-status-icon">⏳</span>
                    <span id="preview-status-text">正在分析数据...</span>
                </div>
            </div>
            
            <div class="import-progress" id="import-progress">
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progress-bar"></div>
                </div>
                <div class="progress-text" id="progress-text">正在解析数据...</div>
            </div>
            
            <div class="import-info">
                <div class="import-info-title">数据格式说明</div>
                <div class="import-info-text">
                    请选择由动捕系统导出的 all.txt 文件，包含关节位置、速度、加速度等数据。
                    文件应为制表符分隔的文本格式。
                </div>
            </div>
            
            <div class="import-actions">
                <button class="import-cancel-btn" id="import-cancel-btn">取消</button>
                <button class="import-confirm-btn" id="import-confirm-btn" disabled>开始分析</button>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="viewer-section">
            <div class="viewer-header">
                <div class="header-content">
                    <div class="header-text">
                        <h1>3D 轨迹图</h1>
                        <div class="subtitle" id="data-subtitle">点击"导入数据"按钮开始分析</div>
                    </div>
                    <div class="header-actions">
                        <button class="import-btn" id="import-btn">
                            <span class="import-icon">📂</span>
                            <span>导入数据</span>
                        </button>
                        <button class="clear-btn" id="clear-btn" style="display: none;">
                            <span class="clear-icon">🗑️</span>
                            <span>清除数据</span>
                        </button>
                    </div>
                </div>
            </div>
            
            <div id="canvas-container">
                <div class="view-controls">
                    <button class="view-btn active" data-view="3d">3D视图</button>
                    <button class="view-btn" data-view="top">俯视图 (X-Y)</button>
                    <button class="view-btn" data-view="side">侧视图 (X-Z)</button>
                    <button class="view-btn" data-view="front">正视图 (Y-Z)</button>
                </div>
                
                <div class="release-legend">
                    <span class="icon">☆</span>
                    <span class="text">释放点 (<span class="speed" id="release-speed">--</span> m/s)</span>
                </div>
                
                <div class="toggle-buttons">
                    <button class="toggle-btn active" id="trajectory-btn" title="显示/隐藏轨迹">
                        <span class="toggle-icon">📍</span>
                        <span class="toggle-text">轨迹</span>
                    </button>
                    <button class="toggle-btn" id="range-trajectory-btn" title="只显示范围内轨迹">
                        <span class="toggle-icon">✂️</span>
                        <span class="toggle-text">范围裁剪</span>
                    </button>
                    <button class="toggle-btn active" id="skeleton-btn" title="显示/隐藏骨架">
                        <span class="toggle-icon">🦴</span>
                        <span class="toggle-text">骨架</span>
                    </button>
                </div>
                
                <!-- 场地控制按钮组 -->
                <div class="circle-control-buttons">
                    <div class="field-type-selector">
                        <select id="field-type-select" title="选择场地类型">
                            <option value="sandpit">🏃 沙坑</option>
                            <option value="discus">🥏 铁饼圈</option>
                            <option value="shotput">🎯 铅球圈</option>
                        </select>
                    </div>
                    <button class="circle-btn" id="circle-move-btn" title="移动场地">
                        <span class="btn-icon">↔️</span>
                        <span>移动</span>
                    </button>
                    <button class="circle-btn save-btn" id="circle-save-btn" title="保存位置" style="display:none;">
                        <span class="btn-icon">💾</span>
                        <span>保存</span>
                    </button>
                    <button class="circle-btn reset-btn" id="circle-reset-btn" title="重置位置" style="display:none;">
                        <span class="btn-icon">↩️</span>
                        <span>重置</span>
                    </button>
                </div>
                
                <div class="circle-position-info" id="circle-position-info">
                    <span id="field-type-label">沙坑</span>: X=<span id="circle-x">0.00</span>m  Y=<span id="circle-y">0.00</span>m
                </div>
                
                <div class="color-legend">
                    <span class="legend-label"><span id="max-speed">--</span> m/s</span>
                    <div class="color-bar"></div>
                    <span class="legend-label"><span id="min-speed">0</span> m/s</span>
                    <span class="legend-title">速度 (m/s)</span>
                </div>
            </div>
            
            <!-- 时间轴控制 -->
            <div class="timeline-control">
                <div class="timeline-header">
                    <div class="playback-controls">
                        <button class="play-btn" id="play-btn">▶</button>
                        <span class="time-display">
                            <span id="current-time">0.00</span>s / <span id="total-time">0.00</span>s
                        </span>
                        
                        <!-- 播放范围设置 -->
                        <div class="control-group">
                            <label>起始帧:</label>
                            <input type="number" id="start-frame" min="0" value="0">
                        </div>
                        <div class="control-group">
                            <label>结束帧:</label>
                            <input type="number" id="end-frame" min="0" value="100">
                        </div>
                        
                        <!-- 循环播放切换 -->
                        <button class="loop-btn active" id="loop-btn" title="循环播放">
                            <span>🔁</span>
                            <span id="loop-text">循环</span>
                        </button>
                        
                        <!-- 播放速度控制 -->
                        <div class="speed-control">
                            <label>速度:</label>
                            <input type="range" class="speed-slider" id="speed-slider" min="0.1" max="2" value="1" step="0.1">
                            <span class="speed-value" id="speed-value">1.0x</span>
                        </div>
                        
                        <!-- 手动设置出手点按钮 -->
                        <div id="set-release-btn-container" style="display: none;">
                            <button id="set-current-frame-release" class="btn btn-secondary" style="font-size: 13px; padding: 6px 12px; display: flex; align-items: center; gap: 4px; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 6px; color: #64748b;">
                                <span class="icon">📍</span> 
                                <span>设为出手点</span>
                            </button>
                        </div>
                    </div>
                    
                    <div class="current-point-info">
                        <span>当前: </span>
                        <span>X=<span id="cur-x">--</span></span>
                        <span>Y=<span id="cur-y">--</span></span>
                        <span>Z=<span id="cur-z">--</span>m</span>
                        <span class="cur-speed">速度=<span id="cur-speed">--</span>m/s</span>
                        <span>帧: <span id="cur-frame">0</span>/<span id="total-frames">0</span></span>
                    </div>
                </div>
                <div class="timeline-slider-container">
                    <div class="range-markers" id="range-markers">
                        <div class="range-indicator" id="range-indicator"></div>
                        <div class="range-start-marker" id="range-start-marker" title="拖动设置起始帧">
                            <div class="range-tooltip" id="start-tooltip">起始: 0</div>
                        </div>
                        <div class="range-end-marker" id="range-end-marker" title="拖动设置结束帧">
                            <div class="range-tooltip" id="end-tooltip">结束: 0</div>
                        </div>
                    </div>
                    <input type="range" id="timeline-slider" min="0" max="100" value="0" step="0.1">
                    <div class="timeline-markers" id="timeline-markers"></div>
                    <!-- 阶段颜色条 -->
                    <div class="phase-color-bar" id="phase-color-bar"></div>
                </div>
            </div>
        </div>
        
        <div class="data-panel">
            <!-- 三列布局容器 -->
            <div class="panel-columns">
                <!-- 第一列：出手参数 -->
                <div class="panel-column collapsible-column" id="column-params">
                    <div class="panel-column-header" onclick="toggleColumn('column-params')">
                        <span>📊</span>
                        <span>出手参数</span>
                        <span class="athlete-info">投掷</span>
                        <button class="column-toggle" title="折叠/展开">▼</button>
                    </div>
                    <div class="panel-column-content">
                        <!-- 关键指标卡片 -->
                        <div class="key-metrics compact">
                            <div class="key-metric-card primary">
                                <div class="label">出手速度</div>
                                <div class="value" id="m-release-vel">--</div>
                                <div class="unit">m/s</div>
                            </div>
                            <div class="key-metric-card">
                                <div class="label">出手高度</div>
                                <div class="value" id="m-release-height">--</div>
                                <div class="unit">m</div>
                            </div>
                            <div class="key-metric-card">
                                <div class="label">出手角度</div>
                                <div class="value" id="m-release-angle">--</div>
                                <div class="unit">°</div>
                            </div>
                            <div class="key-metric-card" style="background: linear-gradient(135deg, rgba(245,158,11,0.08), rgba(245,158,11,0.03)); border-color: rgba(245,158,11,0.3);">
                                <div class="label" style="color: #d97706;">预估距离</div>
                                <div class="value" id="m-estimated-dist" style="color: #d97706;">--</div>
                                <div class="unit">m</div>
                            </div>
                            <div class="key-metric-card">
                                <div class="label">最大速度</div>
                                <div class="value" id="m-max-speed">--</div>
                                <div class="unit">m/s</div>
                            </div>
                        </div>
                        
                        <!-- 详细参数 -->
                        <div class="metrics-group compact">
                            <h3>运动参数</h3>
                            <div class="metric-item">
                                <span class="name">动作时间</span>
                                <span><span class="value" id="m-time">--</span><span class="unit">s</span></span>
                            </div>
                            <div class="metric-item">
                                <span class="name">轨迹长度</span>
                                <span><span class="value" id="m-trajectory">--</span><span class="unit">m</span></span>
                            </div>
                        </div>
                        
                        <div class="metrics-group compact">
                            <h3>释放点坐标</h3>
                            <div class="metric-item">
                                <span class="name">X</span>
                                <span><span class="value" id="m-pos-x">--</span><span class="unit">m</span></span>
                            </div>
                            <div class="metric-item">
                                <span class="name">Y</span>
                                <span><span class="value" id="m-pos-y">--</span><span class="unit">m</span></span>
                            </div>
                            <div class="metric-item">
                                <span class="name">Z</span>
                                <span><span class="value" id="m-pos-z">--</span><span class="unit">m</span></span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 第二列：图表数据 -->
                <div class="panel-column collapsible-column" id="column-charts">
                    <div class="panel-column-header" onclick="toggleColumn('column-charts')">
                        <span>📈</span>
                        <span>数据图表</span>
                        <button class="column-toggle" title="折叠/展开">▼</button>
                    </div>
                    <div class="panel-column-content chart-column-content">
                        <div class="chart-tabs compact">
                            <button class="chart-tab active" data-chart="speed">速度</button>
                            <button class="chart-tab" data-chart="com">重心</button>
                            <button class="chart-tab" data-chart="joint">关节</button>
                        </div>
                        
                        <div class="chart-panels">
                            <!-- 铁饼速度-时间曲线 -->
                            <div class="chart-panel active" id="chart-panel-speed">
                                <div class="chart-panel-header">
                                    <div class="chart-value-display">
                                        <span id="chart-hover-time">--</span>s | 
                                        <span id="chart-hover-speed">--</span>m/s
                                    </div>
                                </div>
                                <div class="chart-wrapper">
                                    <div class="y-axis-label">速度 (m/s)</div>
                                    <div class="chart-area">
                                        <canvas id="speed-chart"></canvas>
                                        <div class="chart-cursor" id="chart-cursor"></div>
                                        <div class="chart-current-line" id="chart-current-line"></div>
                                    </div>
                                </div>
                                <div class="x-axis-label">时间 (s)</div>
                            </div>
                            
                            <!-- 重心分析图 -->
                            <div class="chart-panel" id="chart-panel-com">
                                <div class="chart-panel-header">
                                    <div class="chart-value-display">
                                        <span id="com-hover-time">--</span>s | 
                                        高度: <span id="com-hover-height" style="color:#22c55e;">--</span>m | 
                                        速度: <span id="com-hover-speed" style="color:#8b5cf6;">--</span>m/s
                                    </div>
                                </div>
                                <div class="chart-wrapper dual-axis">
                                    <div class="y-axis-label left-axis" style="color:#22c55e;">高度</div>
                                    <div class="chart-area">
                                        <canvas id="com-chart"></canvas>
                                        <div class="chart-cursor" id="com-chart-cursor"></div>
                                        <div class="chart-current-line" id="com-chart-current-line"></div>
                                    </div>
                                    <div class="y-axis-label right-axis" style="color:#8b5cf6;">速度</div>
                                </div>
                                <div class="x-axis-label">时间 (s)</div>
                                <div class="chart-legend">
                                    <span class="legend-item"><span class="legend-color" style="background:#22c55e;"></span>高度</span>
                                    <span class="legend-item"><span class="legend-color" style="background:#8b5cf6;"></span>速度</span>
                                </div>
                            </div>
                            
                            <!-- 关节速度图 -->
                            <div class="chart-panel" id="chart-panel-joint">
                                <div class="chart-panel-header">
                                    <div class="joint-selector-wrapper">
                                        <select id="joint-selector" class="joint-selector">
                                            <option value="">选择关节...</option>
                                        </select>
                                        <button id="add-joint-btn" class="add-joint-btn" title="添加对比">+</button>
                                    </div>
                                    <div class="chart-value-display">
                                        <span id="joint-hover-time">--</span>s | 
                                        <span id="joint-hover-speed">--</span>m/s
                                    </div>
                                </div>
                                <div class="selected-joints" id="selected-joints"></div>
                                <div class="chart-wrapper">
                                    <div class="y-axis-label">速度 (m/s)</div>
                                    <div class="chart-area" style="height: 140px;">
                                        <canvas id="joint-chart"></canvas>
                                        <div class="chart-cursor" id="joint-chart-cursor"></div>
                                        <div class="chart-current-line" id="joint-chart-current-line"></div>
                                    </div>
                                </div>
                                <div class="x-axis-label">时间 (s)</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 第三列：技术阶段分析 -->
                <div class="panel-column collapsible-column" id="column-phases">
                    <div class="panel-column-header" onclick="toggleColumn('column-phases')">
                        <span>🎯</span>
                        <span>技术阶段</span>
                        <div class="phase-actions" id="phase-actions" style="display: none;">
                            <button class="phase-btn danger small" id="phase-reset-btn" title="重置" onclick="event.stopPropagation(); resetPhases();">
                                ↺
                            </button>
                        </div>
                        <button class="column-toggle" title="折叠/展开">▼</button>
                    </div>
                    <div class="panel-column-content phase-column-content">
                <!-- 初始状态：选择划分方式 -->
                <div class="phase-initial" id="phase-initial">
                    <div class="phase-initial-text">请选择阶段划分方式</div>
                    <div class="phase-initial-buttons">
                        <button class="phase-mode-btn" id="auto-phase-btn">
                            <span class="icon">🤖</span>
                            <span class="label">自动划分</span>
                            <span class="desc">基于生物力学特征</span>
                        </button>
                        <button class="phase-mode-btn" id="manual-phase-btn">
                            <span class="icon">✏️</span>
                            <span class="label">手动划分</span>
                            <span class="desc">自定义阶段时间</span>
                        </button>
                    </div>
                </div>
                
                <!-- 阶段列表（自动/手动划分后显示） -->
                <div class="phase-list" id="phase-list" style="display: none;">
                    <!-- 阶段项目将通过JS动态添加 -->
                </div>
                
                <!-- 手动模式下的添加按钮 -->
                <button class="phase-add-btn" id="phase-add-btn" style="display: none;">
                    + 添加阶段
                </button>
                
                <!-- 阶段编辑对话框 -->
                <div class="phase-dialog-overlay" id="phase-dialog-overlay">
                    <div class="phase-dialog">
                        <div class="phase-dialog-title" id="phase-dialog-title">添加技术阶段</div>
                        <div class="phase-dialog-field">
                            <label>阶段名称</label>
                            <input type="text" id="phase-name-input" placeholder="例如：预摆阶段">
                        </div>
                        <div class="phase-dialog-field">
                            <label>开始时间 (秒)</label>
                            <input type="number" id="phase-start-input" step="0.001" min="0">
                        </div>
                        <div class="phase-dialog-field">
                            <label>结束时间 (秒)</label>
                            <input type="number" id="phase-end-input" step="0.001" min="0">
                        </div>
                        <div class="phase-dialog-field">
                            <label>颜色</label>
                            <div class="phase-dialog-colors" id="phase-color-options">
                                <div class="phase-color-option selected" data-color="#22c55e" style="background:#22c55e;"></div>
                                <div class="phase-color-option" data-color="#3b82f6" style="background:#3b82f6;"></div>
                                <div class="phase-color-option" data-color="#f97316" style="background:#f97316;"></div>
                                <div class="phase-color-option" data-color="#8b5cf6" style="background:#8b5cf6;"></div>
                                <div class="phase-color-option" data-color="#ef4444" style="background:#ef4444;"></div>
                                <div class="phase-color-option" data-color="#ec4899" style="background:#ec4899;"></div>
                                <div class="phase-color-option" data-color="#14b8a6" style="background:#14b8a6;"></div>
                                <div class="phase-color-option" data-color="#eab308" style="background:#eab308;"></div>
                            </div>
                        </div>
                        <div class="phase-dialog-actions">
                            <button class="phase-dialog-btn cancel" id="phase-dialog-cancel">取消</button>
                            <button class="phase-dialog-btn confirm" id="phase-dialog-confirm">确定</button>
                        </div>
                    </div>
                    </div>
                    </div><!-- phase-column-content end -->
                </div><!-- column-phases end -->
            </div><!-- panel-columns end -->
            
            <div class="panel-footer">
                <div class="trajectory-legend">
                    <div class="legend-item">
                        <div class="legend-dot discus"></div>
                        <span>铁饼轨迹</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot com"></div>
                        <span>身体重心轨迹</span>
                    </div>
                </div>
                <div class="footer-note">
                    动作捕捉数据分析 · 生物力学评估系统
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/fflate.min.js"></script>
    
    <script>
        // 折叠/展开功能（旧版section）
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.classList.toggle('collapsed');
                // 保存状态到localStorage
                const isCollapsed = section.classList.contains('collapsed');
                localStorage.setItem(`${sectionId}-collapsed`, isCollapsed);
            }
        }
        
        // 折叠/展开列功能
        function toggleColumn(columnId) {
            const column = document.getElementById(columnId);
            if (column) {
                column.classList.toggle('collapsed');
                // 保存状态到localStorage
                const isCollapsed = column.classList.contains('collapsed');
                localStorage.setItem(`${columnId}-collapsed`, isCollapsed);
                
                // 检查是否所有面板都折叠了
                checkAllColumnsCollapsed();
            }
        }
        
        // 检查是否所有列都折叠
        function checkAllColumnsCollapsed() {
            const dataPanel = document.querySelector('.data-panel');
            const columns = document.querySelectorAll('.panel-column.collapsible-column');
            const allCollapsed = Array.from(columns).every(col => col.classList.contains('collapsed'));
            
            if (allCollapsed) {
                dataPanel.classList.add('all-collapsed');
            } else {
                dataPanel.classList.remove('all-collapsed');
            }
        }
        
        // 初始化折叠状态
        function initCollapsibleSections() {
            // 旧版section折叠（如果存在）
            ['phase-section', 'chart-section'].forEach(sectionId => {
                const isCollapsed = localStorage.getItem(`${sectionId}-collapsed`) === 'true';
                const section = document.getElementById(sectionId);
                if (section && isCollapsed) {
                    section.classList.add('collapsed');
                }
            });
            
            // 新版列折叠（包含出手参数）
            ['column-params', 'column-charts', 'column-phases'].forEach(columnId => {
                const isCollapsed = localStorage.getItem(`${columnId}-collapsed`) === 'true';
                const column = document.getElementById(columnId);
                if (column && isCollapsed) {
                    column.classList.add('collapsed');
                }
            });
            
            // 检查初始状态
            checkAllColumnsCollapsed();
        }
        
        // 全局变量
        let scene, camera, renderer, controls;
        let discusData, comData, skeletonData, releasePoint, biomechanics;
        let discusLine, comLine, releaseMarker;
        let currentView = '3d';
        let currentPointMarker;  // 当前时间点标记
        let currentIndex = 0;    // 当前时间索引
        let isPlaying = false;   // 是否播放中
        let playInterval = null; // 播放定时器
        let skeletonGroup;       // 骨架组
        let skeletonVisible = true; // 骨架是否可见
        let rotationData = null;     // 旋转数据
        
        // 关节角度配置 - 定义每个关节的三点关系用于计算角度
        const JOINT_ANGLE_CONFIG = {
            'knee_r': { parent: 'hip_r', current: 'knee_r', child: 'ankle_r', name: '右膝' },
            'knee_l': { parent: 'hip_l', current: 'knee_l', child: 'ankle_l', name: '左膝' },
            'hip_r': { parent: 'pelvis', current: 'hip_r', child: 'knee_r', name: '右髋' },
            'hip_l': { parent: 'pelvis', current: 'hip_l', child: 'knee_l', name: '左髋' },
            'elbow_r': { parent: 'shoulder_r', current: 'elbow_r', child: 'wrist_r', name: '右肘' },
            'elbow_l': { parent: 'shoulder_l', current: 'elbow_l', child: 'wrist_l', name: '左肘' },
            'shoulder_r': { parent: 'torso', current: 'shoulder_r', child: 'elbow_r', name: '右肩' },
            'shoulder_l': { parent: 'torso', current: 'shoulder_l', child: 'elbow_l', name: '左肩' },
            'ankle_r': { parent: 'knee_r', current: 'ankle_r', child: 'foot_r', name: '右踝' },
            'ankle_l': { parent: 'knee_l', current: 'ankle_l', child: 'foot_l', name: '左踝' },
            'wrist_r': { parent: 'elbow_r', current: 'wrist_r', child: 'hand_index_r', name: '右腕' },
            'wrist_l': { parent: 'elbow_l', current: 'wrist_l', child: 'hand_index_l', name: '左腕' },
            'neck': { parent: 'torso', current: 'neck', child: 'head', name: '颈部' },
            'torso': { parent: 'spine_low', current: 'torso', child: 'neck', name: '躯干' },
            'pelvis': { parent: 'hip_l', current: 'pelvis', child: 'hip_r', name: '骨盆' },
        };
        
        // 角度可视化相关变量
        let angleVisualsGroup;           // 角度可视化组
        let angleVisuals = {};           // 存储每个关节的角度可视化对象 { jointName: { arc, label, highlight } }
        let cameraFocusAnimation = null; // 相机聚焦动画
        
        // 播放控制变量
        let isLooping = true;         // 是否循环播放
        let playbackSpeed = 1.0;      // 播放速度 (0.1 - 2.0)
        let startFrame = 0;           // 播放起始帧
        let endFrame = 0;             // 播放结束帧
        let baseInterval = 30;        // 基础播放间隔 (ms)
        
        // 显示控制变量
        let trajectoryVisible = true;      // 轨迹是否可见
        let rangeClipEnabled = false;      // 是否启用范围裁剪
        let trajectoryGroup;               // 轨迹组（用于统一控制）
        let rangeTrajectoryLine;           // 范围内轨迹线
        
        // 场地变量
        let longJumpGroup;                 // 场地组（沙坑或投掷圈）
        let currentFieldType = 'sandpit';  // 当前场地类型: 'sandpit' 或 'throwing'
        let gizmoGroup;                    // 移动工具组
        let gizmoEnabled = false;          // 是否启用移动工具
        let isDraggingGizmo = false;       // 是否正在拖拽Gizmo
        let dragAxis = null;               // 当前拖拽的轴 ('x', 'y', 或 null)
        
        // 技术阶段相关变量
        let autoPhases = [];               // 自动检测的阶段
        let manualPhases = [];             // 手动添加的阶段
        let currentPhases = [];            // 当前使用的阶段列表
        let phaseMode = null;              // 'auto' 或 'manual' 或 null
        let editingPhaseId = null;         // 正在编辑的阶段ID
        let selectedPhaseColor = '#22c55e'; // 选中的阶段颜色
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let dragPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);  // XY平面
        let dragStartPos = new THREE.Vector3();
        let savedLongJumpPosition = { x: 0, y: 0 };  // 保存的位置
        
        // 颜色映射函数
        function speedToColor(speed, minSpeed, maxSpeed) {
            const t = Math.min(1, Math.max(0, (speed - minSpeed) / (maxSpeed - minSpeed)));
            
            // 蓝色 -> 紫色 -> 粉红 -> 红色 -> 橙色
            const colors = [
                [59, 130, 246],    // 蓝色
                [139, 92, 246],    // 紫色
                [217, 70, 239],    // 粉紫
                [244, 63, 94],     // 红色
                [249, 115, 22]     // 橙色
            ];
            
            const idx = t * (colors.length - 1);
            const i = Math.floor(idx);
            const f = idx - i;
            
            if (i >= colors.length - 1) {
                return colors[colors.length - 1];
            }
            
            const c1 = colors[i];
            const c2 = colors[i + 1];
            
            return [
                Math.round(c1[0] + (c2[0] - c1[0]) * f),
                Math.round(c1[1] + (c2[1] - c1[1]) * f),
                Math.round(c1[2] + (c2[2] - c1[2]) * f)
            ];
        }
        
        // 初始化Three.js场景
        function initScene() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8fafc);
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
            camera.position.set(5, 5, 5);
            camera.up.set(0, 0, 1);  // Z轴向上
            camera.lookAt(0, 0, 1);
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true
            });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            renderer.domElement.id = 'three-canvas';
            
            // 添加控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 0, 1);
            
            // 添加网格
            addGrid();
            
            // 添加坐标轴
            addAxes();
            
            // 窗口大小调整
            window.addEventListener('resize', onWindowResize);
        }
        
        // 添加网格
        function addGrid() {
            // XY平面网格（地面）- Z=0 是地面
            const gridHelper = new THREE.GridHelper(6, 12, 0xcbd5e1, 0xe2e8f0);
            gridHelper.rotation.x = Math.PI / 2;  // 旋转到XY平面
            gridHelper.position.z = 0;
            scene.add(gridHelper);
            
            // 创建场地组
            longJumpGroup = new THREE.Group();
            longJumpGroup.name = 'fieldFacility';
            
            // 根据当前场地类型创建场地
            if (currentFieldType === 'discus') {
                createDiscusCircle();
            } else if (currentFieldType === 'shotput') {
                createShotputCircle();
            } else {
                createSandpit();
            }
            
            scene.add(longJumpGroup);
            
            // 创建移动Gizmo（初始隐藏）
            createGizmo();
        }
        
        // 创建沙坑场地
        function createSandpit() {
            // 清空现有内容
            while (longJumpGroup.children.length > 0) {
                const child = longJumpGroup.children[0];
                longJumpGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            }
            
            // ========== 跳远场地尺寸（国际田联标准） ==========
            const sandPitLength = 9.0;        // 沙坑长度 9m
            const sandPitWidth = 2.75;        // 沙坑宽度 2.75m
            const sandPitDepth = 0.3;         // 沙坑深度 0.3m
            const takeoffBoardLength = 1.22;  // 起跳板长度 1.22m
            const takeoffBoardWidth = 0.20;   // 起跳板宽度 20cm
            const runwayLength = 15.0;        // 助跑道长度（显示部分）
            const runwayWidth = 1.22;         // 助跑道宽度 1.22m
            
            // ========== 沙坑（凹陷式） ==========
            const sandPitCenterY = sandPitLength / 2 + 1.0;  // 沙坑中心Y位置
            const wallThickness = 0.08;  // 墙壁厚度
            
            // 沙坑底部（沙子表面，在地面以下）
            // 地面是XY平面(Z=0)，PlaneGeometry默认在XY平面，所以不需要旋转
            const sandBottomGeometry = new THREE.PlaneGeometry(sandPitWidth, sandPitLength);
            const sandBottomMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xf5d699,  // 沙黄色
                side: THREE.DoubleSide
            });
            const sandBottom = new THREE.Mesh(sandBottomGeometry, sandBottomMaterial);
            sandBottom.position.set(0, sandPitCenterY, -sandPitDepth);
            // 不旋转，保持在XY平面（与地面平行）
            longJumpGroup.add(sandBottom);
            
            // 沙坑四面墙壁（棕色木质）
            const wallMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x8b4513,  // 棕色
                side: THREE.DoubleSide
            });
            
            // 使用 BoxGeometry 创建薄墙壁，比 PlaneGeometry 更容易控制方向
            const wallThick = 0.02;  // 墙壁厚度
            
            // 前墙（靠近起跳板方向）- 垂直于Y轴，从地面向下延伸
            const frontWallGeometry = new THREE.BoxGeometry(sandPitWidth, wallThick, sandPitDepth);
            const frontWall = new THREE.Mesh(frontWallGeometry, wallMaterial);
            frontWall.position.set(0, sandPitCenterY - sandPitLength / 2, -sandPitDepth / 2);
            longJumpGroup.add(frontWall);
            
            // 后墙
            const backWall = new THREE.Mesh(frontWallGeometry, wallMaterial);
            backWall.position.set(0, sandPitCenterY + sandPitLength / 2, -sandPitDepth / 2);
            longJumpGroup.add(backWall);
            
            // 左墙 - 垂直于X轴
            const sideWallGeometry = new THREE.BoxGeometry(wallThick, sandPitLength, sandPitDepth);
            const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            leftWall.position.set(-sandPitWidth / 2, sandPitCenterY, -sandPitDepth / 2);
            longJumpGroup.add(leftWall);
            
            // 右墙
            const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            rightWall.position.set(sandPitWidth / 2, sandPitCenterY, -sandPitDepth / 2);
            longJumpGroup.add(rightWall);
            
            // 沙坑顶部边框（木质边缘，在地面高度）
            const borderWidth = 0.1;  // 边框宽度
            const borderMaterial = new THREE.MeshBasicMaterial({ color: 0x654321 });  // 深棕色
            
            // 前边框
            const frontBorderGeometry = new THREE.BoxGeometry(sandPitWidth + borderWidth * 2, borderWidth, 0.05);
            const frontBorder = new THREE.Mesh(frontBorderGeometry, borderMaterial);
            frontBorder.position.set(0, sandPitCenterY - sandPitLength / 2 - borderWidth / 2, 0.025);
            longJumpGroup.add(frontBorder);
            
            // 后边框
            const backBorder = new THREE.Mesh(frontBorderGeometry, borderMaterial);
            backBorder.position.set(0, sandPitCenterY + sandPitLength / 2 + borderWidth / 2, 0.025);
            longJumpGroup.add(backBorder);
            
            // 左边框
            const sideBorderGeometry = new THREE.BoxGeometry(borderWidth, sandPitLength, 0.05);
            const leftBorder = new THREE.Mesh(sideBorderGeometry, borderMaterial);
            leftBorder.position.set(-sandPitWidth / 2 - borderWidth / 2, sandPitCenterY, 0.025);
            longJumpGroup.add(leftBorder);
            
            // 右边框
            const rightBorder = new THREE.Mesh(sideBorderGeometry, borderMaterial);
            rightBorder.position.set(sandPitWidth / 2 + borderWidth / 2, sandPitCenterY, 0.025);
            longJumpGroup.add(rightBorder);
            
            // 沙坑底部纹理效果（模拟沙子纹理）
            for (let i = 0; i < 8; i++) {
                const sandLineGeometry = new THREE.BufferGeometry();
                const yOffset = -sandPitLength / 2 + (i + 0.5) * (sandPitLength / 8);
                const sandLinePoints = [
                    new THREE.Vector3(-sandPitWidth / 2 + 0.1, yOffset, -sandPitDepth + 0.01),
                    new THREE.Vector3(sandPitWidth / 2 - 0.1, yOffset, -sandPitDepth + 0.01),
                ];
                sandLineGeometry.setFromPoints(sandLinePoints);
                const sandLineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xe8c869,
                    transparent: true,
                    opacity: 0.5
                });
                const sandLine = new THREE.Line(sandLineGeometry, sandLineMaterial);
                sandLine.position.y = sandPitCenterY;
                longJumpGroup.add(sandLine);
            }
            
            // ========== 起跳板 ==========
            const takeoffBoardGeometry = new THREE.BoxGeometry(takeoffBoardWidth, takeoffBoardLength, 0.02);
            const takeoffBoardMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff  // 白色起跳板
            });
            const takeoffBoard = new THREE.Mesh(takeoffBoardGeometry, takeoffBoardMaterial);
            takeoffBoard.position.set(0, 0, 0.01);
            takeoffBoard.rotation.z = Math.PI / 2;  // 横向放置
            longJumpGroup.add(takeoffBoard);
            
            // 起跳板边框
            const takeoffBoardEdges = new THREE.EdgesGeometry(takeoffBoardGeometry);
            const takeoffBoardLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x333333,
                linewidth: 2
            });
            const takeoffBoardWireframe = new THREE.LineSegments(takeoffBoardEdges, takeoffBoardLineMaterial);
            takeoffBoardWireframe.position.copy(takeoffBoard.position);
            takeoffBoardWireframe.rotation.copy(takeoffBoard.rotation);
            longJumpGroup.add(takeoffBoardWireframe);
            
            // 起跳板前的橡皮泥（犯规检测区） - 红色
            const plasticineGeometry = new THREE.BoxGeometry(0.10, takeoffBoardLength, 0.015);
            const plasticineMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xef4444  // 红色
            });
            const plasticine = new THREE.Mesh(plasticineGeometry, plasticineMaterial);
            plasticine.position.set(0, takeoffBoardWidth / 2 + 0.05, 0.008);
            plasticine.rotation.z = Math.PI / 2;
            longJumpGroup.add(plasticine);
            
            // ========== 助跑道 ==========
            const runwayGeometry = new THREE.BoxGeometry(runwayWidth, runwayLength, 0.01);
            const runwayMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xd97706,  // 橘红色跑道
                transparent: true,
                opacity: 0.7
            });
            const runway = new THREE.Mesh(runwayGeometry, runwayMaterial);
            runway.position.set(0, -runwayLength / 2 - takeoffBoardWidth / 2, 0.005);
            longJumpGroup.add(runway);
            
            // 助跑道边线
            const runwayEdges = new THREE.EdgesGeometry(runwayGeometry);
            const runwayLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0xffffff,
                linewidth: 2
            });
            const runwayWireframe = new THREE.LineSegments(runwayEdges, runwayLineMaterial);
            runwayWireframe.position.copy(runway.position);
            longJumpGroup.add(runwayWireframe);
            
            // 助跑道距离标记线（每米一条）
            for (let i = 1; i <= Math.floor(runwayLength); i++) {
                const markerLineGeometry = new THREE.BufferGeometry();
                const markerPoints = [
                    new THREE.Vector3(-runwayWidth / 2, -i - takeoffBoardWidth / 2, 0.015),
                    new THREE.Vector3(runwayWidth / 2, -i - takeoffBoardWidth / 2, 0.015),
                ];
                markerLineGeometry.setFromPoints(markerPoints);
                const markerLineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.6
                });
                const markerLine = new THREE.Line(markerLineGeometry, markerLineMaterial);
                longJumpGroup.add(markerLine);
            }
            
            // ========== 犯规线（起跳板前沿） ==========
            const foulLineGeometry = new THREE.BufferGeometry();
            const foulLinePoints = [
                new THREE.Vector3(-takeoffBoardLength / 2, takeoffBoardWidth / 2 + 0.1, 0.02),
                new THREE.Vector3(takeoffBoardLength / 2, takeoffBoardWidth / 2 + 0.1, 0.02),
            ];
            foulLineGeometry.setFromPoints(foulLinePoints);
            const foulLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0xef4444,
                linewidth: 3
            });
            const foulLine = new THREE.Line(foulLineGeometry, foulLineMaterial);
            longJumpGroup.add(foulLine);
        }
        
        // 创建距离标签精灵
        function createDistanceLabel(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 64;
            
            // 背景（半透明白色）
            ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
            ctx.beginPath();
            ctx.moveTo(8, 0);
            ctx.lineTo(120, 0);
            ctx.quadraticCurveTo(128, 0, 128, 8);
            ctx.lineTo(128, 56);
            ctx.quadraticCurveTo(128, 64, 120, 64);
            ctx.lineTo(8, 64);
            ctx.quadraticCurveTo(0, 64, 0, 56);
            ctx.lineTo(0, 8);
            ctx.quadraticCurveTo(0, 0, 8, 0);
            ctx.fill();
            
            // 边框
            ctx.strokeStyle = '#666666';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // 文字
            ctx.fillStyle = '#333333';
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 64, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true
            });
            const sprite = new THREE.Sprite(material);
            
            return sprite;
        }
        
        // 创建铁饼投掷圈（直径2.50m）
        function createDiscusCircle() {
            // 清空现有内容
            while (longJumpGroup.children.length > 0) {
                const child = longJumpGroup.children[0];
                longJumpGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            }
            
            // ========== 投掷圈尺寸（国际田联标准） ==========
            const circleRadius = 1.25;        // 投掷圈半径 2.5m直径
            const circleRingWidth = 0.05;     // 金属环宽度
            const sectorAngle = 34.92 * Math.PI / 180;  // 投掷扇区角度（约35度）
            const sectorLength = 80;          // 扇区长度（m）
            
            // ========== 投掷圈（混凝土圆盘） ==========
            // 圆盘底面
            const circleGeometry = new THREE.CircleGeometry(circleRadius, 64);
            const circleMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xcccccc,  // 灰色混凝土
                side: THREE.DoubleSide
            });
            const circle = new THREE.Mesh(circleGeometry, circleMaterial);
            circle.position.set(0, 0, 0.005);
            longJumpGroup.add(circle);
            
            // 投掷圈金属边框
            const ringGeometry = new THREE.RingGeometry(circleRadius - circleRingWidth, circleRadius, 64);
            const ringMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x666666,  // 深灰色金属
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.set(0, 0, 0.01);
            longJumpGroup.add(ring);
            
            // 投掷圈外边线
            const circleEdgeGeometry = new THREE.BufferGeometry();
            const circleEdgePoints = [];
            for (let i = 0; i <= 64; i++) {
                const angle = (i / 64) * Math.PI * 2;
                circleEdgePoints.push(new THREE.Vector3(
                    Math.cos(angle) * circleRadius,
                    Math.sin(angle) * circleRadius,
                    0.015
                ));
            }
            circleEdgeGeometry.setFromPoints(circleEdgePoints);
            const circleEdgeMaterial = new THREE.LineBasicMaterial({ 
                color: 0x333333,
                linewidth: 2
            });
            const circleEdge = new THREE.Line(circleEdgeGeometry, circleEdgeMaterial);
            longJumpGroup.add(circleEdge);
            
            // ========== 投掷扇区（落地区域） ==========
            // 扇区线 - 铁饼最远可达70m
            const sectorLineLength = 70;
            
            // 左边线
            const leftLineGeometry = new THREE.BufferGeometry();
            const leftLinePoints = [
                new THREE.Vector3(0, 0, 0.008),
                new THREE.Vector3(
                    -Math.sin(sectorAngle / 2) * sectorLineLength,
                    Math.cos(sectorAngle / 2) * sectorLineLength,
                    0.008
                )
            ];
            leftLineGeometry.setFromPoints(leftLinePoints);
            const sectorLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0xffffff,
                linewidth: 2
            });
            const leftLine = new THREE.Line(leftLineGeometry, sectorLineMaterial);
            longJumpGroup.add(leftLine);
            
            // 右边线
            const rightLineGeometry = new THREE.BufferGeometry();
            const rightLinePoints = [
                new THREE.Vector3(0, 0, 0.008),
                new THREE.Vector3(
                    Math.sin(sectorAngle / 2) * sectorLineLength,
                    Math.cos(sectorAngle / 2) * sectorLineLength,
                    0.008
                )
            ];
            rightLineGeometry.setFromPoints(rightLinePoints);
            const rightLine = new THREE.Line(rightLineGeometry, sectorLineMaterial);
            longJumpGroup.add(rightLine);
            
            // 扇区填充（透明）
            const sectorShape = new THREE.Shape();
            sectorShape.moveTo(0, 0);
            sectorShape.lineTo(
                -Math.sin(sectorAngle / 2) * sectorLineLength,
                Math.cos(sectorAngle / 2) * sectorLineLength
            );
            // 弧线连接
            const arcPoints = 32;
            for (let i = 0; i <= arcPoints; i++) {
                const a = -sectorAngle / 2 + (sectorAngle * i / arcPoints);
                sectorShape.lineTo(
                    Math.sin(a) * sectorLineLength,
                    Math.cos(a) * sectorLineLength
                );
            }
            sectorShape.lineTo(0, 0);
            
            const sectorGeometry = new THREE.ShapeGeometry(sectorShape);
            const sectorMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x90EE90,  // 浅绿色
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide
            });
            const sector = new THREE.Mesh(sectorGeometry, sectorMaterial);
            sector.position.z = 0.003;
            longJumpGroup.add(sector);
            
            // ========== 距离标记弧线和标注 ==========
            const distances = [10, 20, 30, 40, 50, 60, 70];
            distances.forEach(dist => {
                if (dist > sectorLineLength) return;
                
                // 弧线
                const arcGeometry = new THREE.BufferGeometry();
                const arcPoints = [];
                for (let i = 0; i <= 32; i++) {
                    const a = -sectorAngle / 2 + (sectorAngle * i / 32);
                    arcPoints.push(new THREE.Vector3(
                        Math.sin(a) * dist,
                        Math.cos(a) * dist,
                        0.008
                    ));
                }
                arcGeometry.setFromPoints(arcPoints);
                const arcMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.5
                });
                const arc = new THREE.Line(arcGeometry, arcMaterial);
                longJumpGroup.add(arc);
                
                // 距离标注（在扇区右侧边线旁）
                const labelAngle = sectorAngle / 2 + 0.05;  // 稍微偏右
                const labelX = Math.sin(labelAngle) * dist;
                const labelY = Math.cos(labelAngle) * dist;
                
                const label = createDistanceLabel(dist + 'm');
                label.position.set(labelX, labelY, 0.1);
                label.scale.set(0.8, 0.8, 1);
                longJumpGroup.add(label);
            });
            
            // ========== 中心点标记 ==========
            const centerDotGeometry = new THREE.CircleGeometry(0.05, 16);
            const centerDotMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                side: THREE.DoubleSide
            });
            const centerDot = new THREE.Mesh(centerDotGeometry, centerDotMaterial);
            centerDot.position.z = 0.02;
            longJumpGroup.add(centerDot);
        }
        
        // 创建铅球投掷圈（直径2.135m，有抵趾板）
        function createShotputCircle() {
            // 清空现有内容
            while (longJumpGroup.children.length > 0) {
                const child = longJumpGroup.children[0];
                longJumpGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            }
            
            // ========== 铅球投掷圈尺寸（国际田联标准） ==========
            const circleRadius = 1.0675;          // 铅球圈半径（直径2.135m）
            const circleRingWidth = 0.06;         // 金属环宽度 6cm
            const sectorAngle = 34.92 * Math.PI / 180;  // 投掷扇区角度（约35度）
            
            // ========== 投掷圈（混凝土圆盘） ==========
            const circleGeometry = new THREE.CircleGeometry(circleRadius, 64);
            const circleMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xb8b8b8,  // 浅灰色混凝土
                side: THREE.DoubleSide
            });
            const circle = new THREE.Mesh(circleGeometry, circleMaterial);
            circle.position.set(0, 0, 0.005);
            longJumpGroup.add(circle);
            
            // 投掷圈金属边框
            const ringGeometry = new THREE.RingGeometry(circleRadius - circleRingWidth, circleRadius, 64);
            const ringMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x555555,  // 深灰色金属
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.set(0, 0, 0.01);
            longJumpGroup.add(ring);
            
            // 投掷圈外边线
            const circleEdgeGeometry = new THREE.BufferGeometry();
            const circleEdgePoints = [];
            for (let i = 0; i <= 64; i++) {
                const angle = (i / 64) * Math.PI * 2;
                circleEdgePoints.push(new THREE.Vector3(
                    Math.cos(angle) * circleRadius,
                    Math.sin(angle) * circleRadius,
                    0.015
                ));
            }
            circleEdgeGeometry.setFromPoints(circleEdgePoints);
            const circleEdgeMaterial = new THREE.LineBasicMaterial({ 
                color: 0x333333,
                linewidth: 2
            });
            const circleEdge = new THREE.Line(circleEdgeGeometry, circleEdgeMaterial);
            longJumpGroup.add(circleEdge);
            
            // ========== 抵趾板（铅球特有，弧形白色木板） ==========
            const stopBoardAngle = 60 * Math.PI / 180;  // 抵趾板弧度（前方60度范围）
            const stopBoardHeight = 0.10;  // 抵趾板高度 10cm
            const stopBoardWidth = 0.112;  // 抵趾板宽度 11.2cm
            const stopBoardInnerRadius = circleRadius;
            const stopBoardOuterRadius = circleRadius + stopBoardWidth;
            
            // 用多个小方块组成弧形抵趾板
            const numSegments = 20;
            const segmentAngle = stopBoardAngle / numSegments;
            const startAngle = Math.PI / 2 - stopBoardAngle / 2;
            
            for (let i = 0; i < numSegments; i++) {
                const angle = startAngle + segmentAngle * (i + 0.5);
                const midRadius = (stopBoardInnerRadius + stopBoardOuterRadius) / 2;
                
                // 计算每个小方块的尺寸
                const segmentLength = segmentAngle * midRadius * 1.1;  // 稍微重叠
                
                const boxGeometry = new THREE.BoxGeometry(segmentLength, stopBoardWidth, stopBoardHeight);
                const boxMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    side: THREE.DoubleSide
                });
                const box = new THREE.Mesh(boxGeometry, boxMaterial);
                
                // 定位：X沿着圆周切线方向，Y是径向
                box.position.set(
                    Math.cos(angle) * midRadius,
                    Math.sin(angle) * midRadius,
                    stopBoardHeight / 2 + 0.01
                );
                // 旋转使其沿着圆周排列
                box.rotation.z = angle - Math.PI / 2;
                
                longJumpGroup.add(box);
            }
            
            // 抵趾板顶部边线（可视化）
            const topEdgeGeometry = new THREE.BufferGeometry();
            const topEdgePoints = [];
            for (let i = 0; i <= 32; i++) {
                const angle = startAngle + (stopBoardAngle * i / 32);
                topEdgePoints.push(new THREE.Vector3(
                    Math.cos(angle) * stopBoardOuterRadius,
                    Math.sin(angle) * stopBoardOuterRadius,
                    stopBoardHeight + 0.02
                ));
            }
            topEdgeGeometry.setFromPoints(topEdgePoints);
            const topEdgeMaterial = new THREE.LineBasicMaterial({ color: 0xcccccc });
            const topEdge = new THREE.Line(topEdgeGeometry, topEdgeMaterial);
            longJumpGroup.add(topEdge);
            
            // ========== 投掷扇区（落地区域） ==========
            const sectorLineLength = 25;  // 显示25m长的扇区线
            
            // 左边线
            const leftLineGeometry = new THREE.BufferGeometry();
            const leftLinePoints = [
                new THREE.Vector3(0, 0, 0.008),
                new THREE.Vector3(
                    Math.sin(-sectorAngle / 2) * sectorLineLength,
                    Math.cos(-sectorAngle / 2) * sectorLineLength,
                    0.008
                )
            ];
            leftLineGeometry.setFromPoints(leftLinePoints);
            const sectorLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0xffffff,
                linewidth: 2
            });
            const leftLine = new THREE.Line(leftLineGeometry, sectorLineMaterial);
            longJumpGroup.add(leftLine);
            
            // 右边线
            const rightLineGeometry = new THREE.BufferGeometry();
            const rightLinePoints = [
                new THREE.Vector3(0, 0, 0.008),
                new THREE.Vector3(
                    Math.sin(sectorAngle / 2) * sectorLineLength,
                    Math.cos(sectorAngle / 2) * sectorLineLength,
                    0.008
                )
            ];
            rightLineGeometry.setFromPoints(rightLinePoints);
            const rightLine = new THREE.Line(rightLineGeometry, sectorLineMaterial.clone());
            longJumpGroup.add(rightLine);
            
            // 扇区填充（半透明）
            const sectorShape = new THREE.Shape();
            sectorShape.moveTo(0, 0);
            sectorShape.lineTo(
                Math.sin(-sectorAngle / 2) * sectorLineLength,
                Math.cos(-sectorAngle / 2) * sectorLineLength
            );
            // 弧线
            const arcSegments = 32;
            for (let i = 0; i <= arcSegments; i++) {
                const a = -sectorAngle / 2 + (sectorAngle * i / arcSegments);
                sectorShape.lineTo(
                    Math.sin(a) * sectorLineLength,
                    Math.cos(a) * sectorLineLength
                );
            }
            sectorShape.lineTo(0, 0);
            
            const sectorGeometry = new THREE.ShapeGeometry(sectorShape);
            const sectorMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x90EE90,  // 浅绿色
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide
            });
            const sector = new THREE.Mesh(sectorGeometry, sectorMaterial);
            sector.position.z = 0.003;
            longJumpGroup.add(sector);
            
            // 距离标记弧线和标注
            [5, 10, 15, 20, 25].forEach(dist => {
                if (dist > sectorLineLength * 1.5) return;
                
                // 弧线
                const arcGeometry = new THREE.BufferGeometry();
                const arcPoints = [];
                for (let i = 0; i <= 32; i++) {
                    const a = -sectorAngle / 2 + (sectorAngle * i / 32);
                    arcPoints.push(new THREE.Vector3(
                        Math.sin(a) * dist,
                        Math.cos(a) * dist,
                        0.008
                    ));
                }
                arcGeometry.setFromPoints(arcPoints);
                const arcMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.5
                });
                const arc = new THREE.Line(arcGeometry, arcMaterial);
                longJumpGroup.add(arc);
                
                // 距离标注（在扇区右侧边线旁）
                const labelAngle = sectorAngle / 2 + 0.05;
                const labelX = Math.sin(labelAngle) * dist;
                const labelY = Math.cos(labelAngle) * dist;
                
                const label = createDistanceLabel(dist + 'm');
                label.position.set(labelX, labelY, 0.1);
                label.scale.set(0.6, 0.6, 1);
                longJumpGroup.add(label);
            });
            
            // ========== 中心点标记 ==========
            const centerDotGeometry = new THREE.CircleGeometry(0.04, 16);
            const centerDotMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                side: THREE.DoubleSide
            });
            const centerDot = new THREE.Mesh(centerDotGeometry, centerDotMaterial);
            centerDot.position.z = 0.02;
            longJumpGroup.add(centerDot);
        }
        
        // 切换场地类型
        function switchFieldType(fieldType) {
            currentFieldType = fieldType;
            
            // 保存当前位置
            const currentPos = longJumpGroup ? {
                x: longJumpGroup.position.x,
                y: longJumpGroup.position.y
            } : { x: 0, y: 0 };
            
            // 根据类型创建新场地
            if (fieldType === 'discus') {
                createDiscusCircle();
            } else if (fieldType === 'shotput') {
                createShotputCircle();
            } else {
                createSandpit();
            }
            
            // 恢复位置
            longJumpGroup.position.x = currentPos.x;
            longJumpGroup.position.y = currentPos.y;
            
            // 更新Gizmo位置
            if (gizmoGroup) {
                gizmoGroup.position.x = currentPos.x;
                gizmoGroup.position.y = currentPos.y;
            }
            
            // 更新位置显示标签
            const fieldLabel = document.getElementById('field-type-label');
            if (fieldLabel) {
                const labels = { sandpit: '沙坑', discus: '铁饼圈', shotput: '铅球圈' };
                fieldLabel.textContent = labels[fieldType] || '场地';
            }
        }
        
        // 创建移动Gizmo
        function createGizmo() {
            gizmoGroup = new THREE.Group();
            gizmoGroup.name = 'gizmo';
            gizmoGroup.visible = false;
            
            const arrowLength = 0.8;
            const arrowHeadLength = 0.15;
            const arrowHeadRadius = 0.06;
            const shaftRadius = 0.025;
            
            // X轴箭头（红色）- 向右
            const xAxisGroup = new THREE.Group();
            xAxisGroup.name = 'xAxis';
            
            // X轴杆
            const xShaftGeom = new THREE.CylinderGeometry(shaftRadius, shaftRadius, arrowLength - arrowHeadLength, 16);
            const xShaftMat = new THREE.MeshBasicMaterial({ color: 0xef4444 });
            const xShaft = new THREE.Mesh(xShaftGeom, xShaftMat);
            xShaft.rotation.z = -Math.PI / 2;
            xShaft.position.x = (arrowLength - arrowHeadLength) / 2;
            xAxisGroup.add(xShaft);
            
            // X轴箭头
            const xHeadGeom = new THREE.ConeGeometry(arrowHeadRadius, arrowHeadLength, 16);
            const xHeadMat = new THREE.MeshBasicMaterial({ color: 0xef4444 });
            const xHead = new THREE.Mesh(xHeadGeom, xHeadMat);
            xHead.rotation.z = -Math.PI / 2;
            xHead.position.x = arrowLength - arrowHeadLength / 2;
            xAxisGroup.add(xHead);
            
            // X轴标签
            const xLabel = createAxisLabel('X', 0xef4444);
            xLabel.position.set(arrowLength + 0.15, 0, 0);
            xAxisGroup.add(xLabel);
            
            gizmoGroup.add(xAxisGroup);
            
            // Y轴箭头（绿色）- 沿Y轴方向（水平面上，额状面方向）
            const yAxisGroup = new THREE.Group();
            yAxisGroup.name = 'yAxis';
            
            // Y轴杆 - CylinderGeometry默认沿局部Y轴，正好是我们需要的方向
            const yShaftGeom = new THREE.CylinderGeometry(shaftRadius, shaftRadius, arrowLength - arrowHeadLength, 16);
            const yShaftMat = new THREE.MeshBasicMaterial({ color: 0x22c55e });
            const yShaft = new THREE.Mesh(yShaftGeom, yShaftMat);
            // 不需要旋转，CylinderGeometry默认沿Y轴
            yShaft.position.y = (arrowLength - arrowHeadLength) / 2;
            yAxisGroup.add(yShaft);
            
            // Y轴箭头头部
            const yHeadGeom = new THREE.ConeGeometry(arrowHeadRadius, arrowHeadLength, 16);
            const yHeadMat = new THREE.MeshBasicMaterial({ color: 0x22c55e });
            const yHead = new THREE.Mesh(yHeadGeom, yHeadMat);
            // ConeGeometry默认尖端朝上（+Y方向），正是我们需要的
            yHead.position.y = arrowLength - arrowHeadLength / 2;
            yAxisGroup.add(yHead);
            
            // Y轴标签
            const yLabel = createAxisLabel('Y', 0x22c55e);
            yLabel.position.set(0, arrowLength + 0.15, 0);
            
            gizmoGroup.add(yAxisGroup);
            
            // 中心点
            const centerGeom = new THREE.SphereGeometry(0.08, 16, 16);
            const centerMat = new THREE.MeshBasicMaterial({ color: 0xf97316 });
            const center = new THREE.Mesh(centerGeom, centerMat);
            center.name = 'center';
            gizmoGroup.add(center);
            
            // Gizmo位置跟随跳高设备，但稍微抬高
            gizmoGroup.position.z = 0.1;
            
            scene.add(gizmoGroup);
            
            // 初始化Gizmo拖拽事件
            initGizmoDrag();
        }
        
        // 创建轴标签
        function createAxisLabel(text, color) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 64;
            
            ctx.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 32, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(0.3, 0.3, 1);
            return sprite;
        }
        
        // 初始化Gizmo拖拽
        function initGizmoDrag() {
            const canvas = renderer.domElement;
            
            canvas.addEventListener('mousedown', onGizmoMouseDown);
            canvas.addEventListener('mousemove', onGizmoMouseMove);
            canvas.addEventListener('mouseup', onGizmoMouseUp);
            canvas.addEventListener('mouseleave', onGizmoMouseUp);
            
            // 触摸支持
            canvas.addEventListener('touchstart', onGizmoTouchStart, { passive: false });
            canvas.addEventListener('touchmove', onGizmoTouchMove, { passive: false });
            canvas.addEventListener('touchend', onGizmoMouseUp);
        }
        
        function getMousePosition(event, rect) {
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
        }
        
        function onGizmoMouseDown(event) {
            if (!gizmoEnabled || !gizmoGroup.visible) return;
            
            const rect = renderer.domElement.getBoundingClientRect();
            getMousePosition(event, rect);
            
            raycaster.setFromCamera(mouse, camera);
            
            // 检测点击的轴
            const xAxisGroup = gizmoGroup.getObjectByName('xAxis');
            const yAxisGroup = gizmoGroup.getObjectByName('yAxis');
            const center = gizmoGroup.getObjectByName('center');
            
            const xIntersects = raycaster.intersectObjects(xAxisGroup.children, true);
            const yIntersects = raycaster.intersectObjects(yAxisGroup.children, true);
            const centerIntersects = raycaster.intersectObjects([center], true);
            
            if (xIntersects.length > 0) {
                dragAxis = 'x';
                isDraggingGizmo = true;
                highlightAxis('x');
            } else if (yIntersects.length > 0) {
                dragAxis = 'y';
                isDraggingGizmo = true;
                highlightAxis('y');
            } else if (centerIntersects.length > 0) {
                dragAxis = 'xy';
                isDraggingGizmo = true;
                highlightAxis('xy');
            }
            
            if (isDraggingGizmo) {
                // controls已经在toggleGizmo中禁用了
                
                // 记录起始位置
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(dragPlane, intersectPoint);
                dragStartPos.copy(intersectPoint);
                
                renderer.domElement.style.cursor = 'grabbing';
            }
        }
        
        function onGizmoMouseMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            getMousePosition(event, rect);
            
            if (isDraggingGizmo) {
                raycaster.setFromCamera(mouse, camera);
                
                const intersectPoint = new THREE.Vector3();
                if (raycaster.ray.intersectPlane(dragPlane, intersectPoint)) {
                    const delta = intersectPoint.sub(dragStartPos);
                    
                    if (dragAxis === 'x') {
                        longJumpGroup.position.x += delta.x;
                    } else if (dragAxis === 'y') {
                        longJumpGroup.position.y += delta.y;
                    } else if (dragAxis === 'xy') {
                        longJumpGroup.position.x += delta.x;
                        longJumpGroup.position.y += delta.y;
                    }
                    
                    // 更新Gizmo位置
                    gizmoGroup.position.x = longJumpGroup.position.x;
                    gizmoGroup.position.y = longJumpGroup.position.y;
                    
                    // 更新起始位置
                    raycaster.ray.intersectPlane(dragPlane, dragStartPos);
                    
                    // 更新显示
                    updateCirclePositionDisplay();
                }
            } else if (gizmoEnabled && gizmoGroup.visible) {
                // 悬停检测
                raycaster.setFromCamera(mouse, camera);
                
                const xAxisGroup = gizmoGroup.getObjectByName('xAxis');
                const yAxisGroup = gizmoGroup.getObjectByName('yAxis');
                const center = gizmoGroup.getObjectByName('center');
                
                const xIntersects = raycaster.intersectObjects(xAxisGroup.children, true);
                const yIntersects = raycaster.intersectObjects(yAxisGroup.children, true);
                const centerIntersects = raycaster.intersectObjects([center], true);
                
                resetAxisColors();
                
                if (xIntersects.length > 0) {
                    highlightAxis('x');
                    renderer.domElement.style.cursor = 'grab';
                } else if (yIntersects.length > 0) {
                    highlightAxis('y');
                    renderer.domElement.style.cursor = 'grab';
                } else if (centerIntersects.length > 0) {
                    highlightAxis('xy');
                    renderer.domElement.style.cursor = 'grab';
                } else {
                    renderer.domElement.style.cursor = 'default';
                }
            }
        }
        
        function onGizmoMouseUp() {
            if (isDraggingGizmo) {
                isDraggingGizmo = false;
                dragAxis = null;
                // 不重新启用controls，保持在移动模式下禁用视图旋转
                // controls只在toggleGizmo关闭时才重新启用
                resetAxisColors();
                renderer.domElement.style.cursor = gizmoEnabled ? 'move' : 'default';
            }
        }
        
        function onGizmoTouchStart(event) {
            event.preventDefault();
            onGizmoMouseDown(event);
        }
        
        function onGizmoTouchMove(event) {
            event.preventDefault();
            onGizmoMouseMove(event);
        }
        
        // 高亮轴
        function highlightAxis(axis) {
            const xAxisGroup = gizmoGroup.getObjectByName('xAxis');
            const yAxisGroup = gizmoGroup.getObjectByName('yAxis');
            const center = gizmoGroup.getObjectByName('center');
            
            if (axis === 'x' || axis === 'xy') {
                xAxisGroup.children.forEach(child => {
                    if (child.material) child.material.color.setHex(0xffaaaa);
                });
            }
            if (axis === 'y' || axis === 'xy') {
                yAxisGroup.children.forEach(child => {
                    if (child.material) child.material.color.setHex(0xaaffaa);
                });
            }
            if (axis === 'xy') {
                center.material.color.setHex(0xffcc00);
            }
        }
        
        // 重置轴颜色
        function resetAxisColors() {
            const xAxisGroup = gizmoGroup.getObjectByName('xAxis');
            const yAxisGroup = gizmoGroup.getObjectByName('yAxis');
            const center = gizmoGroup.getObjectByName('center');
            
            if (xAxisGroup) {
                xAxisGroup.children.forEach(child => {
                    if (child.material && child.type !== 'Sprite') {
                        child.material.color.setHex(0xef4444);
                    }
                });
            }
            if (yAxisGroup) {
                yAxisGroup.children.forEach(child => {
                    if (child.material && child.type !== 'Sprite') {
                        child.material.color.setHex(0x22c55e);
                    }
                });
            }
            if (center) {
                center.material.color.setHex(0xf97316);
            }
        }
        
        // 切换Gizmo显示
        function toggleGizmo() {
            gizmoEnabled = !gizmoEnabled;
            
            const moveBtn = document.getElementById('circle-move-btn');
            const saveBtn = document.getElementById('circle-save-btn');
            const resetBtn = document.getElementById('circle-reset-btn');
            
            moveBtn.classList.toggle('active', gizmoEnabled);
            
            if (gizmoEnabled) {
                // 禁用轨道控制器，防止拖动时旋转视图
                controls.enabled = false;
                
                gizmoGroup.visible = true;
                gizmoGroup.position.x = longJumpGroup.position.x;
                gizmoGroup.position.y = longJumpGroup.position.y;
                saveBtn.style.display = 'flex';
                resetBtn.style.display = 'flex';
                
                // 显示位置信息
                document.getElementById('circle-position-info').classList.add('visible');
                updateCirclePositionDisplay();
                
                // 提示用户
                renderer.domElement.style.cursor = 'move';
            } else {
                // 重新启用轨道控制器
                controls.enabled = true;
                
                gizmoGroup.visible = false;
                saveBtn.style.display = 'none';
                resetBtn.style.display = 'none';
                
                // 如果位置在原点，隐藏位置信息
                if (Math.abs(longJumpGroup.position.x) < 0.01 && 
                    Math.abs(longJumpGroup.position.y) < 0.01) {
                    document.getElementById('circle-position-info').classList.remove('visible');
                }
                
                renderer.domElement.style.cursor = 'default';
            }
        }
        
        // 保存跳远场地位置
        function saveCirclePosition() {
            savedLongJumpPosition.x = longJumpGroup.position.x;
            savedLongJumpPosition.y = longJumpGroup.position.y;
            
            // 视觉反馈
            const saveBtn = document.getElementById('circle-save-btn');
            saveBtn.innerHTML = '<span class="btn-icon">✅</span><span>已保存</span>';
            setTimeout(() => {
                saveBtn.innerHTML = '<span class="btn-icon">💾</span><span>保存</span>';
            }, 1500);
            
            console.log('跳远场地位置已保存:', savedLongJumpPosition);
        }
        
        // 重置跳远场地位置到保存的位置
        function resetCirclePosition() {
            longJumpGroup.position.x = savedLongJumpPosition.x;
            longJumpGroup.position.y = savedLongJumpPosition.y;
            
            gizmoGroup.position.x = savedLongJumpPosition.x;
            gizmoGroup.position.y = savedLongJumpPosition.y;
            
            updateCirclePositionDisplay();
        }
        
        // 更新跳远场地位置显示
        function updateCirclePositionDisplay() {
            if (!longJumpGroup) return;
            
            document.getElementById('circle-x').textContent = longJumpGroup.position.x.toFixed(2);
            document.getElementById('circle-y').textContent = longJumpGroup.position.y.toFixed(2);
        }
        
        // 添加坐标轴
        function addAxes() {
            const axisLength = 2;
            const axisWidth = 2;
            
            // X轴 - 红色
            const xGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(axisLength, 0, 0)
            ]);
            const xMat = new THREE.LineBasicMaterial({ color: 0xff4444 });
            scene.add(new THREE.Line(xGeom, xMat));
            
            // Y轴 - 绿色
            const yGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, axisLength, 0)
            ]);
            const yMat = new THREE.LineBasicMaterial({ color: 0x44ff44 });
            scene.add(new THREE.Line(yGeom, yMat));
            
            // Z轴 - 蓝色
            const zGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, axisLength)
            ]);
            const zMat = new THREE.LineBasicMaterial({ color: 0x4444ff });
            scene.add(new THREE.Line(zGeom, zMat));
            
            // 轴标签
            addAxisLabel('X', axisLength + 0.15, 0, 0, 0xef4444);
            addAxisLabel('Y', 0, axisLength + 0.15, 0, 0x22c55e);
            addAxisLabel('Z', 0, 0, axisLength + 0.15, 0x3b82f6);
        }
        
        function addAxisLabel(text, x, y, z, color) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 64;
            
            ctx.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 32, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, y, z);
            sprite.scale.set(0.3, 0.3, 1);
            scene.add(sprite);
        }
        
        // 创建铁饼轨迹
        function createDiscusTrajectory() {
            if (!discusData || !discusData.positions.length) return;
            
            const positions = discusData.positions;
            const speeds = discusData.speeds;
            const minSpeed = 0;
            const maxSpeed = Math.max(...speeds);
            
            // 更新速度显示
            document.getElementById('max-speed').textContent = maxSpeed.toFixed(1);
            document.getElementById('min-speed').textContent = '0';
            
            // 创建轨迹组
            trajectoryGroup = new THREE.Group();
            trajectoryGroup.name = 'trajectoryGroup';
            
            // 创建渐变色轨迹
            const points = [];
            const colors = [];
            
            for (let i = 0; i < positions.length; i++) {
                const [x, y, z] = positions[i];
                points.push(new THREE.Vector3(x, y, z));
                
                const color = speedToColor(speeds[i], minSpeed, maxSpeed);
                colors.push(color[0] / 255, color[1] / 255, color[2] / 255);
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.LineBasicMaterial({ 
                vertexColors: true,
                linewidth: 3
            });
            
            discusLine = new THREE.Line(geometry, material);
            discusLine.name = 'fullTrajectory';
            trajectoryGroup.add(discusLine);
            
            // 添加散点增强视觉效果
            const pointsGeometry = new THREE.BufferGeometry().setFromPoints(
                points.filter((_, i) => i % 3 === 0)
            );
            const pointsColors = [];
            for (let i = 0; i < positions.length; i += 3) {
                const color = speedToColor(speeds[i], minSpeed, maxSpeed);
                pointsColors.push(color[0] / 255, color[1] / 255, color[2] / 255);
            }
            pointsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(pointsColors, 3));
            
            const pointsMaterial = new THREE.PointsMaterial({
                size: 0.03,
                vertexColors: true
            });
            
            const pointsCloud = new THREE.Points(pointsGeometry, pointsMaterial);
            pointsCloud.name = 'fullTrajectoryPoints';
            trajectoryGroup.add(pointsCloud);
            
            scene.add(trajectoryGroup);
        }
        
        // 更新范围内轨迹
        function updateRangeTrajectory() {
            if (!discusData || !trajectoryGroup) return;
            
            // 移除旧的范围轨迹
            const oldRangeLine = trajectoryGroup.getObjectByName('rangeTrajectory');
            const oldRangePoints = trajectoryGroup.getObjectByName('rangeTrajectoryPoints');
            if (oldRangeLine) trajectoryGroup.remove(oldRangeLine);
            if (oldRangePoints) trajectoryGroup.remove(oldRangePoints);
            
            // 获取完整轨迹对象
            const fullLine = trajectoryGroup.getObjectByName('fullTrajectory');
            const fullPoints = trajectoryGroup.getObjectByName('fullTrajectoryPoints');
            
            if (rangeClipEnabled) {
                // 隐藏完整轨迹
                if (fullLine) fullLine.visible = false;
                if (fullPoints) fullPoints.visible = false;
                
                // 创建范围内轨迹
                const positions = discusData.positions;
                const speeds = discusData.speeds;
                const minSpeed = 0;
                const maxSpeed = Math.max(...speeds);
                
                const rangePoints = [];
                const rangeColors = [];
                
                for (let i = startFrame; i <= endFrame && i < positions.length; i++) {
                    const [x, y, z] = positions[i];
                    rangePoints.push(new THREE.Vector3(x, y, z));
                    
                    const color = speedToColor(speeds[i], minSpeed, maxSpeed);
                    rangeColors.push(color[0] / 255, color[1] / 255, color[2] / 255);
                }
                
                if (rangePoints.length > 1) {
                    // 创建范围线
                    const geometry = new THREE.BufferGeometry().setFromPoints(rangePoints);
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute(rangeColors, 3));
                    
                    const material = new THREE.LineBasicMaterial({ 
                        vertexColors: true,
                        linewidth: 3
                    });
                    
                    rangeTrajectoryLine = new THREE.Line(geometry, material);
                    rangeTrajectoryLine.name = 'rangeTrajectory';
                    trajectoryGroup.add(rangeTrajectoryLine);
                    
                    // 创建范围散点
                    const rangePointsFiltered = rangePoints.filter((_, i) => i % 2 === 0);
                    const rangePointsColors = [];
                    for (let i = startFrame; i <= endFrame && i < positions.length; i += 2) {
                        const color = speedToColor(speeds[i], minSpeed, maxSpeed);
                        rangePointsColors.push(color[0] / 255, color[1] / 255, color[2] / 255);
                    }
                    
                    const pointsGeometry = new THREE.BufferGeometry().setFromPoints(rangePointsFiltered);
                    pointsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(rangePointsColors, 3));
                    
                    const pointsMaterial = new THREE.PointsMaterial({
                        size: 0.04,
                        vertexColors: true
                    });
                    
                    const rangePointsCloud = new THREE.Points(pointsGeometry, pointsMaterial);
                    rangePointsCloud.name = 'rangeTrajectoryPoints';
                    trajectoryGroup.add(rangePointsCloud);
                }
            } else {
                // 显示完整轨迹
                if (fullLine) fullLine.visible = true;
                if (fullPoints) fullPoints.visible = true;
            }
        }
        
        // 切换轨迹显示
        function toggleTrajectory() {
            trajectoryVisible = !trajectoryVisible;
            const btn = document.getElementById('trajectory-btn');
            
            if (trajectoryGroup) {
                trajectoryGroup.visible = trajectoryVisible;
            }
            if (comLine) {
                comLine.visible = trajectoryVisible;
            }
            
            btn.classList.toggle('active', trajectoryVisible);
        }
        
        // 切换范围裁剪
        function toggleRangeClip() {
            rangeClipEnabled = !rangeClipEnabled;
            const btn = document.getElementById('range-trajectory-btn');
            
            btn.classList.toggle('active', rangeClipEnabled);
            
            updateRangeTrajectory();
        }
        
        // 创建重心轨迹
        function createComTrajectory() {
            if (!comData || !comData.positions.length) return;
            
            const positions = comData.positions;
            const points = positions.map(p => new THREE.Vector3(p[0], p[1], p[2]));
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineDashedMaterial({
                color: 0x94a3b8,
                dashSize: 0.05,
                gapSize: 0.03,
                linewidth: 1
            });
            
            comLine = new THREE.Line(geometry, material);
            comLine.computeLineDistances();
            scene.add(comLine);
        }
        
        // 创建释放点标记
        function createReleaseMarker() {
            if (!releasePoint) return;
            
            const pos = releasePoint.position;
            
            // 星形标记
            const starGeometry = new THREE.BufferGeometry();
            const starPoints = [];
            const outerRadius = 0.1;
            const innerRadius = 0.04;
            
            for (let i = 0; i < 10; i++) {
                const angle = (i * Math.PI) / 5 - Math.PI / 2;
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                starPoints.push(
                    Math.cos(angle) * radius,
                    Math.sin(angle) * radius,
                    0
                );
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPoints, 3));
            
            const starMaterial = new THREE.LineBasicMaterial({ color: 0xf97316 });
            const star = new THREE.LineLoop(starGeometry, starMaterial);
            star.position.set(pos[0], pos[1], pos[2]);
            
            // 让星形始终面向相机
            star.lookAt(camera.position);
            
            scene.add(star);
            
            // 添加发光球体
            const sphereGeometry = new THREE.SphereGeometry(0.05, 16, 16);
            const sphereMaterial = new THREE.MeshBasicMaterial({
                color: 0xf97316,
                transparent: true,
                opacity: 0.9
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.set(pos[0], pos[1], pos[2]);
            scene.add(sphere);
            
            releaseMarker = { star, sphere };
        }
        
        // 创建当前时间点标记
        function createCurrentPointMarker() {
            // 大球体作为当前点标记
            const geometry = new THREE.SphereGeometry(0.08, 32, 32);
            const material = new THREE.MeshBasicMaterial({
                color: 0x22c55e,
                transparent: true,
                opacity: 0.9
            });
            currentPointMarker = new THREE.Mesh(geometry, material);
            
            // 添加外环
            const ringGeometry = new THREE.RingGeometry(0.1, 0.12, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x22c55e,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.6
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            currentPointMarker.add(ring);
            
            scene.add(currentPointMarker);
            
            // 初始位置
            if (discusData && discusData.positions.length > 0) {
                updateCurrentPoint(0);
            }
        }
        
        // 更新当前时间点
        function updateCurrentPoint(index) {
            if (!discusData || !discusData.positions.length) return;
            
            currentIndex = Math.min(Math.max(0, index), discusData.positions.length - 1);
            const pos = discusData.positions[currentIndex];
            const speed = discusData.speeds[currentIndex];
            const time = discusData.times[currentIndex];
            
            // 更新标记位置
            if (currentPointMarker) {
                currentPointMarker.position.set(pos[0], pos[1], pos[2]);
                
                // 根据速度改变颜色
                const color = speedToColor(speed, 0, Math.max(...discusData.speeds));
                currentPointMarker.material.color.setRGB(color[0]/255, color[1]/255, color[2]/255);
            }
            
            // 更新骨架位置
            updateSkeleton(currentIndex);
            
            // 更新UI显示
            document.getElementById('current-time').textContent = time.toFixed(2);
            document.getElementById('cur-x').textContent = pos[0].toFixed(2);
            document.getElementById('cur-y').textContent = pos[1].toFixed(2);
            document.getElementById('cur-z').textContent = pos[2].toFixed(2);
            document.getElementById('cur-speed').textContent = speed.toFixed(1);
            document.getElementById('cur-frame').textContent = currentIndex;
            
            // 更新滑块位置
            const slider = document.getElementById('timeline-slider');
            slider.value = (currentIndex / (discusData.positions.length - 1)) * 100;
            
            // 更新图表当前时间线
            updateChartCurrentLine();
        }
        
        // 初始化时间轴
        function initTimeline() {
            if (!discusData) return;
            
            const times = discusData.times;
            const totalTime = times[times.length - 1];
            const maxFrame = discusData.positions.length - 1;
            
            document.getElementById('total-time').textContent = totalTime.toFixed(2);
            document.getElementById('total-frames').textContent = maxFrame;
            
            // 初始化播放范围
            endFrame = maxFrame;
            document.getElementById('start-frame').max = maxFrame;
            document.getElementById('end-frame').max = maxFrame;
            document.getElementById('end-frame').value = maxFrame;
            
            // 更新范围指示器
            updateRangeIndicator();
            
            // 添加释放点标记
            if (releasePoint) {
                const releasePercent = (releasePoint.time / totalTime) * 100;
                const marker = document.createElement('div');
                marker.className = 'timeline-marker';
                marker.style.left = releasePercent + '%';
                document.getElementById('timeline-markers').appendChild(marker);
            }
            
            // 滑块事件
            const slider = document.getElementById('timeline-slider');
            slider.addEventListener('input', (e) => {
                const percent = e.target.value / 100;
                const index = Math.round(percent * (discusData.positions.length - 1));
                updateCurrentPoint(index);
            });
            
            // 播放按钮事件
            document.getElementById('play-btn').addEventListener('click', togglePlay);
            
            // 循环按钮事件
            document.getElementById('loop-btn').addEventListener('click', toggleLoop);
            
            // 速度滑块事件
            document.getElementById('speed-slider').addEventListener('input', (e) => {
                updatePlaybackSpeed(e.target.value);
            });
            
            // 播放范围输入事件
            document.getElementById('start-frame').addEventListener('change', updatePlayRange);
            document.getElementById('end-frame').addEventListener('change', updatePlayRange);
            
            // 初始化拖拽功能
            initRangeMarkerDrag();
            
            // 键盘快捷键
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT') return; // 忽略输入框中的按键
                
                switch (e.key) {
                    case ' ': // 空格键播放/暂停
                        e.preventDefault();
                        togglePlay();
                        break;
                    case 'ArrowLeft': // 左箭头后退一帧
                        e.preventDefault();
                        if (currentIndex > startFrame) {
                            updateCurrentPoint(currentIndex - 1);
                        }
                        break;
                    case 'ArrowRight': // 右箭头前进一帧
                        e.preventDefault();
                        if (currentIndex < endFrame) {
                            updateCurrentPoint(currentIndex + 1);
                        }
                        break;
                    case 'Home': // Home键跳到起始帧
                        e.preventDefault();
                        updateCurrentPoint(startFrame);
                        break;
                    case 'End': // End键跳到结束帧
                        e.preventDefault();
                        updateCurrentPoint(endFrame);
                        break;
                    case 'l': // L键切换循环
                        e.preventDefault();
                        toggleLoop();
                        break;
                }
            });
        }
        
        // 播放/暂停
        function togglePlay() {
            isPlaying = !isPlaying;
            const btn = document.getElementById('play-btn');
            
            if (isPlaying) {
                btn.textContent = '⏸';
                btn.classList.add('playing');
                
                // 隐藏手动设置出手点按钮
                const setReleaseBtn = document.getElementById('set-release-btn-container');
                if (setReleaseBtn) setReleaseBtn.style.display = 'none';
                
                // 如果当前帧在范围外，重置到起始帧
                if (currentIndex < startFrame || currentIndex >= endFrame) {
                    currentIndex = startFrame;
                    updateCurrentPoint(currentIndex);
                }
                
                startPlayback();
            } else {
                stopPlayback();
                btn.textContent = '▶';
                btn.classList.remove('playing');
                
                // 显示手动设置出手点按钮
                const setReleaseBtn = document.getElementById('set-release-btn-container');
                if (setReleaseBtn) {
                    setReleaseBtn.style.display = 'flex';
                    setReleaseBtn.style.alignItems = 'center';
                }
            }
        }
        
        // 开始播放
        function startPlayback() {
            if (playInterval) {
                clearInterval(playInterval);
            }
            
            const interval = Math.max(10, baseInterval / playbackSpeed);
            
            playInterval = setInterval(() => {
                let nextIndex = currentIndex + 1;
                
                // 检查是否到达结束帧
                if (nextIndex > endFrame) {
                    if (isLooping) {
                        // 循环播放：回到起始帧
                        nextIndex = startFrame;
                    } else {
                        // 单次播放：停止播放
                        stopPlayback();
                        document.getElementById('play-btn').textContent = '▶';
                        document.getElementById('play-btn').classList.remove('playing');
                        isPlaying = false;
                        return;
                    }
                }
                
                updateCurrentPoint(nextIndex);
            }, interval);
        }
        
        // 停止播放
        function stopPlayback() {
            if (playInterval) {
                clearInterval(playInterval);
                playInterval = null;
            }
        }
        
        // 切换循环模式
        function toggleLoop() {
            isLooping = !isLooping;
            const btn = document.getElementById('loop-btn');
            const text = document.getElementById('loop-text');
            
            btn.classList.toggle('active', isLooping);
            text.textContent = isLooping ? '循环' : '单次';
        }
        
        // 更新播放速度
        function updatePlaybackSpeed(speed) {
            playbackSpeed = parseFloat(speed);
            document.getElementById('speed-value').textContent = playbackSpeed.toFixed(1) + 'x';
            
            // 如果正在播放，重新启动以应用新速度
            if (isPlaying) {
                startPlayback();
            }
        }
        
        // 更新播放范围
        function updatePlayRange() {
            const maxFrame = discusData ? discusData.positions.length - 1 : 100;
            
            startFrame = Math.max(0, Math.min(parseInt(document.getElementById('start-frame').value) || 0, maxFrame));
            endFrame = Math.max(startFrame, Math.min(parseInt(document.getElementById('end-frame').value) || maxFrame, maxFrame));
            
            // 更新输入框显示
            document.getElementById('start-frame').value = startFrame;
            document.getElementById('end-frame').value = endFrame;
            
            // 更新范围指示器
            updateRangeIndicator();
            
            // 如果启用了范围裁剪，更新轨迹显示
            if (rangeClipEnabled) {
                updateRangeTrajectory();
            }
            
            // 如果当前帧在范围外，调整到范围内
            if (currentIndex < startFrame) {
                updateCurrentPoint(startFrame);
            } else if (currentIndex > endFrame) {
                updateCurrentPoint(endFrame);
            }
        }
        
        // 更新范围指示器
        function updateRangeIndicator() {
            const maxFrame = discusData ? discusData.positions.length - 1 : 100;
            const startPercent = (startFrame / maxFrame) * 100;
            const endPercent = (endFrame / maxFrame) * 100;
            
            const indicator = document.getElementById('range-indicator');
            const startMarker = document.getElementById('range-start-marker');
            const endMarker = document.getElementById('range-end-marker');
            const startTooltip = document.getElementById('start-tooltip');
            const endTooltip = document.getElementById('end-tooltip');
            
            if (indicator) {
                indicator.style.left = startPercent + '%';
                indicator.style.width = (endPercent - startPercent) + '%';
            }
            
            if (startMarker) {
                startMarker.style.left = startPercent + '%';
            }
            
            if (endMarker) {
                endMarker.style.left = endPercent + '%';
            }
            
            // 更新提示文字
            if (startTooltip) {
                const startTime = discusData && discusData.times[startFrame] ? discusData.times[startFrame].toFixed(2) : '0.00';
                startTooltip.textContent = `起始: ${startFrame} (${startTime}s)`;
            }
            
            if (endTooltip) {
                const endTime = discusData && discusData.times[endFrame] ? discusData.times[endFrame].toFixed(2) : '0.00';
                endTooltip.textContent = `结束: ${endFrame} (${endTime}s)`;
            }
        }
        
        // 拖拽标记功能
        let isDragging = null; // 'start' or 'end'
        
        function initRangeMarkerDrag() {
            const startMarker = document.getElementById('range-start-marker');
            const endMarker = document.getElementById('range-end-marker');
            const sliderContainer = document.querySelector('.timeline-slider-container');
            
            // 起始标记拖拽
            startMarker.addEventListener('mousedown', (e) => {
                e.preventDefault();
                isDragging = 'start';
                startMarker.classList.add('dragging');
                document.body.style.cursor = 'ew-resize';
            });
            
            // 结束标记拖拽
            endMarker.addEventListener('mousedown', (e) => {
                e.preventDefault();
                isDragging = 'end';
                endMarker.classList.add('dragging');
                document.body.style.cursor = 'ew-resize';
            });
            
            // 触摸事件支持
            startMarker.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDragging = 'start';
                startMarker.classList.add('dragging');
            });
            
            endMarker.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDragging = 'end';
                endMarker.classList.add('dragging');
            });
            
            // 鼠标移动
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('touchmove', handleDrag);
            
            // 鼠标释放
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
        }
        
        function handleDrag(e) {
            if (!isDragging || !discusData) return;
            
            const sliderContainer = document.querySelector('.timeline-slider-container');
            const rect = sliderContainer.getBoundingClientRect();
            
            // 获取鼠标/触摸位置
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            
            // 计算百分比位置
            let percent = (clientX - rect.left) / rect.width;
            percent = Math.max(0, Math.min(1, percent));
            
            const maxFrame = discusData.positions.length - 1;
            const frameIndex = Math.round(percent * maxFrame);
            
            if (isDragging === 'start') {
                // 确保起始帧不超过结束帧
                startFrame = Math.min(frameIndex, endFrame - 1);
                document.getElementById('start-frame').value = startFrame;
            } else if (isDragging === 'end') {
                // 确保结束帧不小于起始帧
                endFrame = Math.max(frameIndex, startFrame + 1);
                document.getElementById('end-frame').value = endFrame;
            }
            
            updateRangeIndicator();
            
            // 如果当前帧在范围外，调整到范围内
            if (currentIndex < startFrame) {
                updateCurrentPoint(startFrame);
            } else if (currentIndex > endFrame) {
                updateCurrentPoint(endFrame);
            }
        }
        
        function stopDrag() {
            if (isDragging) {
                const startMarker = document.getElementById('range-start-marker');
                const endMarker = document.getElementById('range-end-marker');
                startMarker.classList.remove('dragging');
                endMarker.classList.remove('dragging');
                document.body.style.cursor = '';
                
                // 拖拽结束后更新范围轨迹
                if (rangeClipEnabled) {
                    updateRangeTrajectory();
                }
                
                isDragging = null;
            }
        }
        
        // 创建骨架
        function createSkeleton() {
            if (!skeletonData || !skeletonData.frames.length) return;
            
            skeletonGroup = new THREE.Group();
            
            // 创建关节点球体
            const jointGeometry = new THREE.SphereGeometry(0.03, 8, 8);
            const jointMaterial = new THREE.MeshBasicMaterial({ color: 0x22c55e });
            
            skeletonData.joint_names.forEach(name => {
                const joint = new THREE.Mesh(jointGeometry, jointMaterial.clone());
                joint.name = 'joint_' + name;
                skeletonGroup.add(joint);
            });
            
            // 创建骨骼连线
            skeletonData.bones.forEach((bone, idx) => {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(6); // 2 points * 3 coords
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x16a34a,
                    linewidth: 2
                });
                const line = new THREE.Line(geometry, material);
                line.name = 'bone_' + idx;
                skeletonGroup.add(line);
            });
            
            scene.add(skeletonGroup);
            
            // 初始更新骨架位置
            updateSkeleton(0);
        }
        
        // 更新骨架位置
        function updateSkeleton(frameIndex) {
            if (!skeletonGroup || !skeletonData) return;
            
            const frame = skeletonData.frames[frameIndex];
            if (!frame) return;
            
            // 更新关节点位置
            skeletonData.joint_names.forEach(name => {
                const joint = skeletonGroup.getObjectByName('joint_' + name);
                if (joint && frame[name]) {
                    joint.position.set(frame[name][0], frame[name][1], frame[name][2]);
                }
            });
            
            // 更新骨骼连线
            skeletonData.bones.forEach((bone, idx) => {
                const line = skeletonGroup.getObjectByName('bone_' + idx);
                if (line && frame[bone[0]] && frame[bone[1]]) {
                    const positions = line.geometry.attributes.position.array;
                    positions[0] = frame[bone[0]][0];
                    positions[1] = frame[bone[0]][1];
                    positions[2] = frame[bone[0]][2];
                    positions[3] = frame[bone[1]][0];
                    positions[4] = frame[bone[1]][1];
                    positions[5] = frame[bone[1]][2];
                    line.geometry.attributes.position.needsUpdate = true;
                }
            });
            
            // 更新关节角度可视化
            updateAngleVisuals(frameIndex);
        }
        
        // 切换骨架显示
        function toggleSkeleton() {
            skeletonVisible = !skeletonVisible;
            const btn = document.getElementById('skeleton-btn');
            
            if (skeletonGroup) {
                skeletonGroup.visible = skeletonVisible;
            }
            
            btn.classList.toggle('active', skeletonVisible);
        }
        
        // ============ 关节角度可视化功能 ============
        
        // 计算三点之间的夹角（度）
        function calculateJointAngle(p1, p2, p3) {
            // p1: 父关节位置, p2: 当前关节位置, p3: 子关节位置
            // 计算向量 p2->p1 和 p2->p3 的夹角
            const v1 = new THREE.Vector3(p1[0] - p2[0], p1[1] - p2[1], p1[2] - p2[2]);
            const v2 = new THREE.Vector3(p3[0] - p2[0], p3[1] - p2[1], p3[2] - p2[2]);
            
            v1.normalize();
            v2.normalize();
            
            const dot = v1.dot(v2);
            const angle = Math.acos(Math.max(-1, Math.min(1, dot)));
            return THREE.MathUtils.radToDeg(angle);
        }
        
        // 初始化角度可视化组
        function initAngleVisualsGroup() {
            if (!angleVisualsGroup) {
                angleVisualsGroup = new THREE.Group();
                angleVisualsGroup.name = 'angleVisuals';
                scene.add(angleVisualsGroup);
            }
        }
        
        // 辅助函数：绘制圆角矩形（兼容性更好）
        function drawRoundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }
        
        // 创建角度标签精灵
        function createAngleLabelSprite(text, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 64;
            
            // 绘制背景
            context.fillStyle = 'rgba(255, 255, 255, 0.95)';
            drawRoundRect(context, 4, 4, 120, 56, 8);
            context.fill();
            
            // 绘制边框
            context.strokeStyle = color;
            context.lineWidth = 3;
            context.stroke();
            
            // 绘制文字
            context.fillStyle = '#1e293b';
            context.font = 'bold 28px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 64, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const material = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                depthTest: false
            });
            
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(0.25, 0.125, 1);
            return sprite;
        }
        
        // 更新角度标签文字
        function updateAngleLabelSprite(sprite, text, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 64;
            
            // 绘制背景
            context.fillStyle = 'rgba(255, 255, 255, 0.95)';
            drawRoundRect(context, 4, 4, 120, 56, 8);
            context.fill();
            
            // 绘制边框
            context.strokeStyle = color;
            context.lineWidth = 3;
            context.stroke();
            
            // 绘制文字
            context.fillStyle = '#1e293b';
            context.font = 'bold 28px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 64, 32);
            
            sprite.material.map.dispose();
            sprite.material.map = new THREE.CanvasTexture(canvas);
            sprite.material.map.needsUpdate = true;
        }
        
        // 创建角度扇形（填充区域）
        function createAngleArc(p1, p2, p3, color, radius = 0.12) {
            // 计算两个方向向量
            const v1 = new THREE.Vector3(p1[0] - p2[0], p1[1] - p2[1], p1[2] - p2[2]).normalize();
            const v2 = new THREE.Vector3(p3[0] - p2[0], p3[1] - p2[1], p3[2] - p2[2]).normalize();
            
            // 计算角度
            const angle = v1.angleTo(v2);
            
            // 创建扇形的顶点
            const segments = 24;
            const vertices = [];
            const indices = [];
            
            // 计算旋转轴（两向量的叉积）
            const axis = new THREE.Vector3().crossVectors(v1, v2).normalize();
            
            // 如果两向量平行，使用默认轴
            if (axis.length() < 0.001) {
                axis.set(0, 1, 0);
            }
            
            // 中心点
            const center = new THREE.Vector3(p2[0], p2[1], p2[2]);
            vertices.push(center.x, center.y, center.z);
            
            // 沿着弧线生成点
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const currentAngle = angle * t;
                
                // 绕轴旋转v1
                const quaternion = new THREE.Quaternion().setFromAxisAngle(axis, currentAngle);
                const point = v1.clone().applyQuaternion(quaternion).multiplyScalar(radius);
                point.add(center);
                vertices.push(point.x, point.y, point.z);
            }
            
            // 创建三角形索引（扇形）
            for (let i = 1; i <= segments; i++) {
                indices.push(0, i, i + 1);
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            
            // 解析颜色
            const threeColor = new THREE.Color(color);
            
            const material = new THREE.MeshBasicMaterial({ 
                color: threeColor,
                transparent: true,
                opacity: 0.35,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            
            // 同时添加边框线
            const edgePoints = [];
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const currentAngle = angle * t;
                const quaternion = new THREE.Quaternion().setFromAxisAngle(axis, currentAngle);
                const point = v1.clone().applyQuaternion(quaternion).multiplyScalar(radius);
                point.add(center);
                edgePoints.push(point);
            }
            
            const edgeGeometry = new THREE.BufferGeometry().setFromPoints(edgePoints);
            const edgeMaterial = new THREE.LineBasicMaterial({ 
                color: threeColor,
                linewidth: 2,
                transparent: true,
                opacity: 0.8
            });
            const edgeLine = new THREE.Line(edgeGeometry, edgeMaterial);
            
            // 创建组合对象
            const group = new THREE.Group();
            group.add(mesh);
            group.add(edgeLine);
            
            return group;
        }
        
        // 创建单个关节的角度可视化
        function createAngleVisual(jointName, color) {
            const config = JOINT_ANGLE_CONFIG[jointName];
            if (!config) return; // 该关节没有角度配置
            
            initAngleVisualsGroup();
            
            // 如果已存在，先移除
            if (angleVisuals[jointName]) {
                removeAngleVisual(jointName);
            }
            
            // 获取当前帧的关节位置
            if (!skeletonData || !skeletonData.frames.length) return;
            
            const frame = skeletonData.frames[currentIndex];
            const p1 = frame[config.parent];
            const p2 = frame[config.current];
            const p3 = frame[config.child];
            
            if (!p1 || !p2 || !p3) return;
            
            // 计算角度
            const angle = calculateJointAngle(p1, p2, p3);
            
            // 创建弧线
            const arc = createAngleArc(p1, p2, p3, color);
            arc.name = 'arc_' + jointName;
            angleVisualsGroup.add(arc);
            
            // 创建标签
            const label = createAngleLabelSprite(angle.toFixed(1) + '°', color);
            label.name = 'label_' + jointName;
            // 放置标签在弧线中间位置稍外侧
            const v1 = new THREE.Vector3(p1[0] - p2[0], p1[1] - p2[1], p1[2] - p2[2]).normalize();
            const v2 = new THREE.Vector3(p3[0] - p2[0], p3[1] - p2[1], p3[2] - p2[2]).normalize();
            const midDir = v1.clone().add(v2).normalize();
            label.position.set(
                p2[0] + midDir.x * 0.18,
                p2[1] + midDir.y * 0.18,
                p2[2] + midDir.z * 0.18
            );
            angleVisualsGroup.add(label);
            
            // 高亮当前关节点
            const highlight = highlightJoint(jointName, color);
            
            // 保存引用
            angleVisuals[jointName] = { arc, label, highlight, color };
        }
        
        // 移除单个关节的角度可视化
        function removeAngleVisual(jointName) {
            const visual = angleVisuals[jointName];
            if (!visual) return;
            
            if (visual.arc) {
                angleVisualsGroup.remove(visual.arc);
                // arc 是一个 Group，需要遍历子对象来 dispose
                visual.arc.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }
            
            if (visual.label) {
                angleVisualsGroup.remove(visual.label);
                if (visual.label.material.map) visual.label.material.map.dispose();
                visual.label.material.dispose();
            }
            
            if (visual.highlight) {
                unhighlightJoint(jointName);
            }
            
            delete angleVisuals[jointName];
        }
        
        // 清除所有角度可视化
        function clearAllAngleVisuals() {
            Object.keys(angleVisuals).forEach(jointName => {
                removeAngleVisual(jointName);
            });
        }
        
        // 更新所有角度可视化（每帧调用）
        function updateAngleVisuals(frameIndex) {
            if (!skeletonData || !angleVisualsGroup) return;
            
            const frame = skeletonData.frames[frameIndex];
            if (!frame) return;
            
            Object.keys(angleVisuals).forEach(jointName => {
                const config = JOINT_ANGLE_CONFIG[jointName];
                const visual = angleVisuals[jointName];
                if (!config || !visual) return;
                
                const p1 = frame[config.parent];
                const p2 = frame[config.current];
                const p3 = frame[config.child];
                
                if (!p1 || !p2 || !p3) return;
                
                // 计算新角度
                const angle = calculateJointAngle(p1, p2, p3);
                
                // 更新扇形（重新创建以反映新角度）
                if (visual.arc) {
                    angleVisualsGroup.remove(visual.arc);
                    // arc 是一个 Group，需要遍历子对象来 dispose
                    visual.arc.traverse(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                    
                    const newArc = createAngleArc(p1, p2, p3, visual.color);
                    newArc.name = 'arc_' + jointName;
                    angleVisualsGroup.add(newArc);
                    visual.arc = newArc;
                }
                
                // 更新标签位置和文字
                if (visual.label) {
                    const v1 = new THREE.Vector3(p1[0] - p2[0], p1[1] - p2[1], p1[2] - p2[2]).normalize();
                    const v2 = new THREE.Vector3(p3[0] - p2[0], p3[1] - p2[1], p3[2] - p2[2]).normalize();
                    const midDir = v1.clone().add(v2).normalize();
                    visual.label.position.set(
                        p2[0] + midDir.x * 0.18,
                        p2[1] + midDir.y * 0.18,
                        p2[2] + midDir.z * 0.18
                    );
                    updateAngleLabelSprite(visual.label, angle.toFixed(1) + '°', visual.color);
                }
            });
        }
        
        // 高亮关节点
        function highlightJoint(jointName, color) {
            if (!skeletonGroup) return null;
            
            const joint = skeletonGroup.getObjectByName('joint_' + jointName);
            if (!joint) return null;
            
            // 保存原始颜色
            joint.userData.originalColor = joint.material.color.getHex();
            
            // 设置高亮颜色
            joint.material.color.setStyle(color);
            
            // 轻微放大关节点（从1.8改为1.3）
            joint.scale.set(1.3, 1.3, 1.3);
            
            return joint;
        }
        
        // 取消高亮关节点
        function unhighlightJoint(jointName) {
            if (!skeletonGroup) return;
            
            const joint = skeletonGroup.getObjectByName('joint_' + jointName);
            if (!joint) return;
            
            // 恢复原始颜色
            if (joint.userData.originalColor !== undefined) {
                joint.material.color.setHex(joint.userData.originalColor);
            } else {
                joint.material.color.setHex(0x22c55e);
            }
            
            // 恢复原始大小
            joint.scale.set(1, 1, 1);
        }
        
        // 相机聚焦到关节位置
        function focusCameraOnJoint(jointName) {
            if (!skeletonData || !skeletonData.frames.length || !controls) return;
            
            const frame = skeletonData.frames[currentIndex];
            const jointPos = frame[jointName];
            if (!jointPos) return;
            
            // 目标位置
            const targetPosition = new THREE.Vector3(jointPos[0], jointPos[1], jointPos[2]);
            
            // 当前相机目标
            const startTarget = controls.target.clone();
            
            // 动画参数
            const duration = 500; // 毫秒
            const startTime = Date.now();
            
            // 取消之前的动画
            if (cameraFocusAnimation) {
                cancelAnimationFrame(cameraFocusAnimation);
            }
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // 使用缓动函数
                const easeProgress = 1 - Math.pow(1 - progress, 3); // easeOutCubic
                
                // 插值相机目标
                controls.target.lerpVectors(startTarget, targetPosition, easeProgress);
                controls.update();
                
                if (progress < 1) {
                    cameraFocusAnimation = requestAnimationFrame(animate);
                } else {
                    cameraFocusAnimation = null;
                }
            }
            
            animate();
        }
        
        // ============ 关节角度可视化功能结束 ============
        
        // 更新数据面板
        function updateDataPanel() {
            if (!biomechanics) return;
            
            document.getElementById('release-speed').textContent = biomechanics.release_velocity.toFixed(1);
            document.getElementById('m-release-vel').textContent = biomechanics.release_velocity.toFixed(1);
            document.getElementById('m-release-height').textContent = biomechanics.release_height.toFixed(2);
            document.getElementById('m-release-angle').textContent = biomechanics.release_angle.toFixed(1);
            document.getElementById('m-max-speed').textContent = biomechanics.max_speed.toFixed(1);
            if (biomechanics.estimated_distance !== undefined) {
                document.getElementById('m-estimated-dist').textContent = biomechanics.estimated_distance.toFixed(2);
            }
            document.getElementById('m-time').textContent = biomechanics.total_time.toFixed(2);
            document.getElementById('m-trajectory').textContent = biomechanics.trajectory_length.toFixed(1);
            
            const pos = biomechanics.release_position;
            document.getElementById('m-pos-x').textContent = pos[0].toFixed(2);
            document.getElementById('m-pos-y').textContent = pos[1].toFixed(2);
            document.getElementById('m-pos-z').textContent = pos[2].toFixed(2);
        }
        
        // 图表相关变量
        let chartData = {
            times: [],
            speeds: [],
            maxSpeed: 0,
            maxTime: 0,
            padding: { left: 45, right: 15, top: 15, bottom: 25 }
        };
        
        // 绘制速度曲线
        function drawSpeedChart() {
            if (!discusData) return;
            
            const canvas = document.getElementById('speed-chart');
            const ctx = canvas.getContext('2d');
            const container = canvas.parentElement;
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            canvas.width = width * window.devicePixelRatio;
            canvas.height = height * window.devicePixelRatio;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            const times = discusData.times;
            const speeds = discusData.speeds;
            const maxSpeed = Math.ceil(Math.max(...speeds) / 5) * 5;  // 向上取整到5的倍数
            const maxTime = Math.ceil(Math.max(...times));
            
            // 保存图表数据供交互使用
            chartData.times = times;
            chartData.speeds = speeds;
            chartData.maxSpeed = maxSpeed;
            chartData.maxTime = maxTime;
            chartData.width = width;
            chartData.height = height;
            
            const p = chartData.padding;
            const chartWidth = width - p.left - p.right;
            const chartHeight = height - p.top - p.bottom;
            
            // 清空画布
            ctx.clearRect(0, 0, width, height);
            
            // 绘制背景网格
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            
            // 水平网格线和Y轴刻度
            const yTicks = 5;
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.font = '10px Arial';
            ctx.fillStyle = '#94a3b8';
            
            for (let i = 0; i <= yTicks; i++) {
                const y = p.top + (chartHeight / yTicks) * i;
                const value = maxSpeed - (maxSpeed / yTicks) * i;
                
                // 网格线
                ctx.beginPath();
                ctx.moveTo(p.left, y);
                ctx.lineTo(width - p.right, y);
                ctx.stroke();
                
                // Y轴刻度值
                ctx.fillText(value.toFixed(0), p.left - 5, y);
            }
            
            // 垂直网格线和X轴刻度
            const xTicks = Math.min(6, Math.ceil(maxTime));
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            for (let i = 0; i <= xTicks; i++) {
                const x = p.left + (chartWidth / xTicks) * i;
                const value = (maxTime / xTicks) * i;
                
                // 网格线
                ctx.beginPath();
                ctx.moveTo(x, p.top);
                ctx.lineTo(x, height - p.bottom);
                ctx.stroke();
                
                // X轴刻度值
                ctx.fillText(value.toFixed(1), x, height - p.bottom + 5);
            }
            
            // 绘制坐标轴
            ctx.strokeStyle = '#cbd5e1';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(p.left, p.top);
            ctx.lineTo(p.left, height - p.bottom);
            ctx.lineTo(width - p.right, height - p.bottom);
            ctx.stroke();
            
            // 绘制速度曲线（渐变填充）
            const gradient = ctx.createLinearGradient(0, p.top, 0, height - p.bottom);
            gradient.addColorStop(0, 'rgba(249, 115, 22, 0.3)');
            gradient.addColorStop(1, 'rgba(59, 130, 246, 0.1)');
            
            ctx.beginPath();
            ctx.moveTo(p.left, height - p.bottom);
            
            for (let i = 0; i < times.length; i++) {
                const x = p.left + (times[i] / maxTime) * chartWidth;
                const y = p.top + (1 - speeds[i] / maxSpeed) * chartHeight;
                ctx.lineTo(x, y);
            }
            
            ctx.lineTo(p.left + (times[times.length-1] / maxTime) * chartWidth, height - p.bottom);
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // 绘制速度曲线（线条）
            ctx.beginPath();
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            
            for (let i = 0; i < times.length; i++) {
                const x = p.left + (times[i] / maxTime) * chartWidth;
                const y = p.top + (1 - speeds[i] / maxSpeed) * chartHeight;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 标记释放点
            if (releasePoint) {
                const x = p.left + (releasePoint.time / maxTime) * chartWidth;
                const y = p.top + (1 - releasePoint.speed / maxSpeed) * chartHeight;
                
                // 释放点竖线
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(249, 115, 22, 0.5)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.moveTo(x, p.top);
                ctx.lineTo(x, height - p.bottom);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 释放点圆圈
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#f97316';
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 释放点标签
                ctx.fillStyle = '#f97316';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('释放点', x, p.top - 5);
            }
            
            // 初始化图表交互
            initChartInteraction();
        }
        
        // 初始化图表交互
        function initChartInteraction() {
            const canvas = document.getElementById('speed-chart');
            const chartArea = canvas.parentElement;
            const cursor = document.getElementById('chart-cursor');
            const currentLine = document.getElementById('chart-current-line');
            
            // 移除旧的事件监听器
            chartArea.onmousemove = null;
            chartArea.onmouseleave = null;
            chartArea.onclick = null;
            
            // 鼠标移动 - 显示悬停信息
            chartArea.addEventListener('mousemove', (e) => {
                const rect = chartArea.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const p = chartData.padding;
                const chartWidth = chartData.width - p.left - p.right;
                
                if (x >= p.left && x <= chartData.width - p.right) {
                    const timePercent = (x - p.left) / chartWidth;
                    const time = timePercent * chartData.maxTime;
                    
                    // 找到最近的数据点
                    let closestIdx = 0;
                    let minDiff = Infinity;
                    for (let i = 0; i < chartData.times.length; i++) {
                        const diff = Math.abs(chartData.times[i] - time);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestIdx = i;
                        }
                    }
                    
                    const speed = chartData.speeds[closestIdx];
                    const actualTime = chartData.times[closestIdx];
                    
                    // 更新显示
                    document.getElementById('chart-hover-time').textContent = actualTime.toFixed(2);
                    document.getElementById('chart-hover-speed').textContent = speed.toFixed(1);
                    
                    // 更新光标位置
                    const cursorX = p.left + (actualTime / chartData.maxTime) * chartWidth;
                    const cursorY = p.top + (1 - speed / chartData.maxSpeed) * (chartData.height - p.top - p.bottom);
                    cursor.style.left = cursorX + 'px';
                    cursor.style.opacity = '1';
                    cursor.querySelector('::before') && (cursor.style.top = cursorY + 'px');
                } else {
                    cursor.style.opacity = '0';
                }
            });
            
            // 鼠标离开
            chartArea.addEventListener('mouseleave', () => {
                cursor.style.opacity = '0';
                document.getElementById('chart-hover-time').textContent = '--';
                document.getElementById('chart-hover-speed').textContent = '--';
            });
            
            // 点击跳转到对应时间点
            chartArea.addEventListener('click', (e) => {
                const rect = chartArea.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const p = chartData.padding;
                const chartWidth = chartData.width - p.left - p.right;
                
                if (x >= p.left && x <= chartData.width - p.right) {
                    const timePercent = (x - p.left) / chartWidth;
                    const time = timePercent * chartData.maxTime;
                    
                    // 找到最近的数据点索引
                    let closestIdx = 0;
                    let minDiff = Infinity;
                    for (let i = 0; i < chartData.times.length; i++) {
                        const diff = Math.abs(chartData.times[i] - time);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestIdx = i;
                        }
                    }
                    
                    // 跳转到该时间点
                    updateCurrentPoint(closestIdx);
                }
            });
        }
        
        // 更新图表上的当前时间线
        function updateChartCurrentLine() {
            if (!discusData || !chartData.times.length) return;
            
            const currentLine = document.getElementById('chart-current-line');
            const p = chartData.padding;
            const chartWidth = chartData.width - p.left - p.right;
            
            const time = discusData.times[currentIndex];
            const x = p.left + (time / chartData.maxTime) * chartWidth;
            
            currentLine.style.left = x + 'px';
            
            // 同时更新重心图表的当前线
            updateComChartCurrentLine();
            
            // 同时更新关节图表的当前线
            updateJointChartCurrentLine();
        }
        
        // 重心图表数据
        let comChartData = {
            times: [],
            heights: [],
            speeds: [],
            maxHeight: 0,
            minHeight: 0,
            maxSpeed: 0,
            maxTime: 0,
            padding: { left: 45, right: 45, top: 15, bottom: 25 }
        };
        
        // 绘制重心分析图（双Y轴）
        function drawComChart() {
            if (!comData) return;
            
            const canvas = document.getElementById('com-chart');
            const ctx = canvas.getContext('2d');
            const container = canvas.parentElement;
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            canvas.width = width * window.devicePixelRatio;
            canvas.height = height * window.devicePixelRatio;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            const times = comData.times;
            const positions = comData.positions;
            const speeds = comData.speeds;
            
            // 提取高度数据（Z坐标）
            const heights = positions.map(p => p[2]);
            
            const maxHeight = Math.ceil(Math.max(...heights) * 10) / 10;
            const minHeight = Math.floor(Math.min(...heights) * 10) / 10;
            const maxSpeed = Math.ceil(Math.max(...speeds) / 2) * 2;
            const maxTime = Math.ceil(Math.max(...times));
            
            // 保存图表数据
            comChartData.times = times;
            comChartData.heights = heights;
            comChartData.speeds = speeds;
            comChartData.maxHeight = maxHeight;
            comChartData.minHeight = minHeight;
            comChartData.maxSpeed = maxSpeed;
            comChartData.maxTime = maxTime;
            comChartData.width = width;
            comChartData.height = height;
            
            const p = comChartData.padding;
            const chartWidth = width - p.left - p.right;
            const chartHeight = height - p.top - p.bottom;
            
            // 清空画布
            ctx.clearRect(0, 0, width, height);
            
            // 绘制背景网格
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            
            const yTicks = 5;
            const xTicks = Math.min(6, Math.ceil(maxTime));
            
            // 水平网格线
            for (let i = 0; i <= yTicks; i++) {
                const y = p.top + (chartHeight / yTicks) * i;
                ctx.beginPath();
                ctx.moveTo(p.left, y);
                ctx.lineTo(width - p.right, y);
                ctx.stroke();
            }
            
            // 垂直网格线和X轴刻度
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.font = '10px Arial';
            ctx.fillStyle = '#94a3b8';
            
            for (let i = 0; i <= xTicks; i++) {
                const x = p.left + (chartWidth / xTicks) * i;
                const value = (maxTime / xTicks) * i;
                
                ctx.beginPath();
                ctx.moveTo(x, p.top);
                ctx.lineTo(x, height - p.bottom);
                ctx.stroke();
                
                ctx.fillText(value.toFixed(1), x, height - p.bottom + 5);
            }
            
            // 左Y轴刻度（高度 - 绿色）
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#22c55e';
            
            for (let i = 0; i <= yTicks; i++) {
                const y = p.top + (chartHeight / yTicks) * i;
                const value = maxHeight - ((maxHeight - minHeight) / yTicks) * i;
                ctx.fillText(value.toFixed(2), p.left - 5, y);
            }
            
            // 右Y轴刻度（速度 - 紫色）
            ctx.textAlign = 'left';
            ctx.fillStyle = '#8b5cf6';
            
            for (let i = 0; i <= yTicks; i++) {
                const y = p.top + (chartHeight / yTicks) * i;
                const value = maxSpeed - (maxSpeed / yTicks) * i;
                ctx.fillText(value.toFixed(1), width - p.right + 5, y);
            }
            
            // 绘制坐标轴
            ctx.lineWidth = 2;
            
            // 左轴（绿色）
            ctx.strokeStyle = '#22c55e';
            ctx.beginPath();
            ctx.moveTo(p.left, p.top);
            ctx.lineTo(p.left, height - p.bottom);
            ctx.stroke();
            
            // 右轴（紫色）
            ctx.strokeStyle = '#8b5cf6';
            ctx.beginPath();
            ctx.moveTo(width - p.right, p.top);
            ctx.lineTo(width - p.right, height - p.bottom);
            ctx.stroke();
            
            // 底轴
            ctx.strokeStyle = '#cbd5e1';
            ctx.beginPath();
            ctx.moveTo(p.left, height - p.bottom);
            ctx.lineTo(width - p.right, height - p.bottom);
            ctx.stroke();
            
            // 绘制高度曲线（绿色填充）
            const heightGradient = ctx.createLinearGradient(0, p.top, 0, height - p.bottom);
            heightGradient.addColorStop(0, 'rgba(34, 197, 94, 0.3)');
            heightGradient.addColorStop(1, 'rgba(34, 197, 94, 0.05)');
            
            ctx.beginPath();
            ctx.moveTo(p.left, height - p.bottom);
            
            for (let i = 0; i < times.length; i++) {
                const x = p.left + (times[i] / maxTime) * chartWidth;
                const y = p.top + (1 - (heights[i] - minHeight) / (maxHeight - minHeight)) * chartHeight;
                ctx.lineTo(x, y);
            }
            
            ctx.lineTo(p.left + (times[times.length-1] / maxTime) * chartWidth, height - p.bottom);
            ctx.closePath();
            ctx.fillStyle = heightGradient;
            ctx.fill();
            
            // 绘制高度曲线（线条）
            ctx.beginPath();
            ctx.strokeStyle = '#22c55e';
            ctx.lineWidth = 2;
            
            for (let i = 0; i < times.length; i++) {
                const x = p.left + (times[i] / maxTime) * chartWidth;
                const y = p.top + (1 - (heights[i] - minHeight) / (maxHeight - minHeight)) * chartHeight;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 绘制速度曲线（紫色）
            ctx.beginPath();
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 2;
            
            for (let i = 0; i < times.length; i++) {
                const x = p.left + (times[i] / maxTime) * chartWidth;
                const y = p.top + (1 - speeds[i] / maxSpeed) * chartHeight;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 标记释放点
            if (releasePoint) {
                const x = p.left + (releasePoint.time / maxTime) * chartWidth;
                
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(249, 115, 22, 0.5)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.moveTo(x, p.top);
                ctx.lineTo(x, height - p.bottom);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // 初始化交互
            initComChartInteraction();
        }
        
        // 初始化重心图表交互
        function initComChartInteraction() {
            const canvas = document.getElementById('com-chart');
            const chartArea = canvas.parentElement;
            const cursor = document.getElementById('com-chart-cursor');
            
            chartArea.addEventListener('mousemove', (e) => {
                const rect = chartArea.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const p = comChartData.padding;
                const chartWidth = comChartData.width - p.left - p.right;
                
                if (x >= p.left && x <= comChartData.width - p.right) {
                    const timePercent = (x - p.left) / chartWidth;
                    const time = timePercent * comChartData.maxTime;
                    
                    let closestIdx = 0;
                    let minDiff = Infinity;
                    for (let i = 0; i < comChartData.times.length; i++) {
                        const diff = Math.abs(comChartData.times[i] - time);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestIdx = i;
                        }
                    }
                    
                    const height = comChartData.heights[closestIdx];
                    const speed = comChartData.speeds[closestIdx];
                    const actualTime = comChartData.times[closestIdx];
                    
                    document.getElementById('com-hover-time').textContent = actualTime.toFixed(2);
                    document.getElementById('com-hover-height').textContent = height.toFixed(3);
                    document.getElementById('com-hover-speed').textContent = speed.toFixed(2);
                    
                    const cursorX = p.left + (actualTime / comChartData.maxTime) * chartWidth;
                    cursor.style.left = cursorX + 'px';
                    cursor.style.opacity = '1';
                } else {
                    cursor.style.opacity = '0';
                }
            });
            
            chartArea.addEventListener('mouseleave', () => {
                cursor.style.opacity = '0';
                document.getElementById('com-hover-time').textContent = '--';
                document.getElementById('com-hover-height').textContent = '--';
                document.getElementById('com-hover-speed').textContent = '--';
            });
            
            chartArea.addEventListener('click', (e) => {
                const rect = chartArea.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const p = comChartData.padding;
                const chartWidth = comChartData.width - p.left - p.right;
                
                if (x >= p.left && x <= comChartData.width - p.right) {
                    const timePercent = (x - p.left) / chartWidth;
                    const time = timePercent * comChartData.maxTime;
                    
                    let closestIdx = 0;
                    let minDiff = Infinity;
                    for (let i = 0; i < comChartData.times.length; i++) {
                        const diff = Math.abs(comChartData.times[i] - time);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestIdx = i;
                        }
                    }
                    
                    updateCurrentPoint(closestIdx);
                }
            });
        }
        
        // 更新重心图表当前时间线
        function updateComChartCurrentLine() {
            if (!comData || !comChartData.times.length) return;
            
            const currentLine = document.getElementById('com-chart-current-line');
            const p = comChartData.padding;
            const chartWidth = comChartData.width - p.left - p.right;
            
            const time = comData.times[currentIndex] || discusData.times[currentIndex];
            const x = p.left + (time / comChartData.maxTime) * chartWidth;
            
            currentLine.style.left = x + 'px';
        }
        
        // 关节速度图相关变量
        let jointSpeedsData = null;
        let selectedJoints = [];
        const jointColors = [
            '#ef4444', '#f97316', '#eab308', '#22c55e', '#14b8a6',
            '#3b82f6', '#8b5cf6', '#ec4899', '#6366f1', '#0ea5e9'
        ];
        let jointChartData = {
            maxSpeed: 0,
            maxTime: 0,
            width: 0,
            height: 0,
            padding: { left: 45, right: 15, top: 15, bottom: 25 }
        };
        
        // 初始化关节选择器
        function initJointSelector() {
            if (!jointSpeedsData) return;
            
            const selector = document.getElementById('joint-selector');
            selector.innerHTML = '<option value="">选择关节...</option>';
            
            // 按类别分组
            const groups = {
                '右臂': ['shoulder_r', 'elbow_r', 'wrist_r', 'hand_index_r', 'hand_little_r'],
                '左臂': ['shoulder_l', 'elbow_l', 'wrist_l', 'hand_index_l', 'hand_little_l'],
                '右腿': ['hip_r', 'knee_r', 'ankle_r', 'foot_r'],
                '左腿': ['hip_l', 'knee_l', 'ankle_l', 'foot_l'],
                '躯干': ['pelvis', 'spine_low', 'spine_high', 'torso', 'neck', 'head']
            };
            
            for (const [groupName, joints] of Object.entries(groups)) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = groupName;
                
                for (const jointName of joints) {
                    if (jointSpeedsData[jointName]) {
                        const option = document.createElement('option');
                        option.value = jointName;
                        option.textContent = jointSpeedsData[jointName].name_cn;
                        optgroup.appendChild(option);
                    }
                }
                
                selector.appendChild(optgroup);
            }
            
            // 绑定事件
            document.getElementById('add-joint-btn').addEventListener('click', addSelectedJoint);
            selector.addEventListener('change', () => {
                if (selector.value) {
                    addJoint(selector.value);
                    selector.value = '';
                }
            });
            
            // 默认添加右腕
            addJoint('wrist_r');
        }
        
        // 添加选中的关节
        function addSelectedJoint() {
            const selector = document.getElementById('joint-selector');
            if (selector.value) {
                addJoint(selector.value);
                selector.value = '';
            }
        }
        
        // 添加关节到对比列表
        function addJoint(jointName) {
            if (selectedJoints.includes(jointName) || selectedJoints.length >= 5) {
                return;
            }
            
            selectedJoints.push(jointName);
            updateSelectedJointsTags();
            drawJointChart();
            
            // 创建角度可视化（使用对应颜色）
            const colorIndex = selectedJoints.indexOf(jointName);
            const color = jointColors[colorIndex % jointColors.length];
            createAngleVisual(jointName, color);
            
            // 相机聚焦到该关节
            focusCameraOnJoint(jointName);
        }
        
        // 移除关节
        function removeJoint(jointName) {
            selectedJoints = selectedJoints.filter(j => j !== jointName);
            updateSelectedJointsTags();
            drawJointChart();
            
            // 移除角度可视化
            removeAngleVisual(jointName);
        }
        
        // 更新选中关节标签
        function updateSelectedJointsTags() {
            const container = document.getElementById('selected-joints');
            container.innerHTML = '';
            
            selectedJoints.forEach((jointName, idx) => {
                const jointData = jointSpeedsData[jointName];
                const color = jointColors[idx % jointColors.length];
                
                const tag = document.createElement('span');
                tag.className = 'joint-tag';
                tag.style.background = color;
                tag.innerHTML = `
                    <span class="color-dot" style="background:white;"></span>
                    ${jointData.name_cn}
                    <button class="remove-btn" onclick="removeJoint('${jointName}')">×</button>
                `;
                container.appendChild(tag);
            });
        }
        
        // 绘制关节速度图
        function drawJointChart() {
            const canvas = document.getElementById('joint-chart');
            if (!canvas || !jointSpeedsData || selectedJoints.length === 0) return;
            
            const ctx = canvas.getContext('2d');
            const container = canvas.parentElement;
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            canvas.width = width * window.devicePixelRatio;
            canvas.height = height * window.devicePixelRatio;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            // 计算数据范围
            let maxSpeed = 0;
            selectedJoints.forEach(jointName => {
                const speeds = jointSpeedsData[jointName].speeds;
                maxSpeed = Math.max(maxSpeed, Math.max(...speeds));
            });
            maxSpeed = Math.ceil(maxSpeed / 5) * 5;
            
            const times = discusData.times;
            const maxTime = Math.ceil(Math.max(...times));
            
            jointChartData.maxSpeed = maxSpeed;
            jointChartData.maxTime = maxTime;
            jointChartData.width = width;
            jointChartData.height = height;
            
            const p = jointChartData.padding;
            const chartWidth = width - p.left - p.right;
            const chartHeight = height - p.top - p.bottom;
            
            // 清空画布
            ctx.clearRect(0, 0, width, height);
            
            // 绘制网格
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            
            const yTicks = 5;
            const xTicks = Math.min(6, Math.ceil(maxTime));
            
            // 水平网格线和Y轴刻度
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.font = '10px Arial';
            ctx.fillStyle = '#94a3b8';
            
            for (let i = 0; i <= yTicks; i++) {
                const y = p.top + (chartHeight / yTicks) * i;
                const value = maxSpeed - (maxSpeed / yTicks) * i;
                
                ctx.beginPath();
                ctx.moveTo(p.left, y);
                ctx.lineTo(width - p.right, y);
                ctx.stroke();
                
                ctx.fillText(value.toFixed(0), p.left - 5, y);
            }
            
            // 垂直网格线和X轴刻度
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            for (let i = 0; i <= xTicks; i++) {
                const x = p.left + (chartWidth / xTicks) * i;
                const value = (maxTime / xTicks) * i;
                
                ctx.beginPath();
                ctx.moveTo(x, p.top);
                ctx.lineTo(x, height - p.bottom);
                ctx.stroke();
                
                ctx.fillText(value.toFixed(1), x, height - p.bottom + 5);
            }
            
            // 绘制坐标轴
            ctx.strokeStyle = '#cbd5e1';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(p.left, p.top);
            ctx.lineTo(p.left, height - p.bottom);
            ctx.lineTo(width - p.right, height - p.bottom);
            ctx.stroke();
            
            // 绘制每个关节的速度曲线
            selectedJoints.forEach((jointName, idx) => {
                const speeds = jointSpeedsData[jointName].speeds;
                const color = jointColors[idx % jointColors.length];
                
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                
                for (let i = 0; i < Math.min(times.length, speeds.length); i++) {
                    const x = p.left + (times[i] / maxTime) * chartWidth;
                    const y = p.top + (1 - speeds[i] / maxSpeed) * chartHeight;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            });
            
            // 标记释放点
            if (releasePoint) {
                const x = p.left + (releasePoint.time / maxTime) * chartWidth;
                
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(249, 115, 22, 0.5)';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.moveTo(x, p.top);
                ctx.lineTo(x, height - p.bottom);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // 初始化交互
            initJointChartInteraction();
        }
        
        // 初始化关节图表交互
        function initJointChartInteraction() {
            const canvas = document.getElementById('joint-chart');
            const chartArea = canvas.parentElement;
            const cursor = document.getElementById('joint-chart-cursor');
            
            chartArea.onmousemove = (e) => {
                const rect = chartArea.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const p = jointChartData.padding;
                const chartWidth = jointChartData.width - p.left - p.right;
                
                if (x >= p.left && x <= jointChartData.width - p.right && selectedJoints.length > 0) {
                    const timePercent = (x - p.left) / chartWidth;
                    const time = timePercent * jointChartData.maxTime;
                    
                    let closestIdx = 0;
                    let minDiff = Infinity;
                    for (let i = 0; i < discusData.times.length; i++) {
                        const diff = Math.abs(discusData.times[i] - time);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestIdx = i;
                        }
                    }
                    
                    const actualTime = discusData.times[closestIdx];
                    
                    // 显示第一个选中关节的速度
                    const firstJoint = selectedJoints[0];
                    const speed = jointSpeedsData[firstJoint].speeds[closestIdx] || 0;
                    
                    document.getElementById('joint-hover-time').textContent = actualTime.toFixed(2);
                    document.getElementById('joint-hover-speed').textContent = speed.toFixed(2);
                    
                    const cursorX = p.left + (actualTime / jointChartData.maxTime) * chartWidth;
                    cursor.style.left = cursorX + 'px';
                    cursor.style.opacity = '1';
                } else {
                    cursor.style.opacity = '0';
                }
            };
            
            chartArea.onmouseleave = () => {
                cursor.style.opacity = '0';
                document.getElementById('joint-hover-time').textContent = '--';
                document.getElementById('joint-hover-speed').textContent = '--';
            };
            
            chartArea.onclick = (e) => {
                const rect = chartArea.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const p = jointChartData.padding;
                const chartWidth = jointChartData.width - p.left - p.right;
                
                if (x >= p.left && x <= jointChartData.width - p.right) {
                    const timePercent = (x - p.left) / chartWidth;
                    const time = timePercent * jointChartData.maxTime;
                    
                    let closestIdx = 0;
                    let minDiff = Infinity;
                    for (let i = 0; i < discusData.times.length; i++) {
                        const diff = Math.abs(discusData.times[i] - time);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestIdx = i;
                        }
                    }
                    
                    updateCurrentPoint(closestIdx);
                }
            };
        }
        
        // 更新关节图表当前时间线
        function updateJointChartCurrentLine() {
            if (!discusData || !jointChartData.maxTime) return;
            
            const currentLine = document.getElementById('joint-chart-current-line');
            if (!currentLine) return;
            
            const p = jointChartData.padding;
            const chartWidth = jointChartData.width - p.left - p.right;
            
            const time = discusData.times[currentIndex];
            const x = p.left + (time / jointChartData.maxTime) * chartWidth;
            
            currentLine.style.left = x + 'px';
        }
        
        // 初始化图表标签页
        function initChartTabs() {
            const tabs = document.querySelectorAll('.chart-tab');
            const panels = document.querySelectorAll('.chart-panel');
            
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const chartType = tab.dataset.chart;
                    
                    // 更新标签状态
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    
                    // 更新面板显示
                    panels.forEach(p => p.classList.remove('active'));
                    document.getElementById(`chart-panel-${chartType}`).classList.add('active');
                    
                    // 切换后重绘图表（确保尺寸正确）
                    setTimeout(() => {
                        if (chartType === 'speed') drawSpeedChart();
                        else if (chartType === 'com') drawComChart();
                        else if (chartType === 'joint') drawJointChart();
                    }, 50);
                });
            });
        }
        
        // 切换视图
        function setView(viewName) {
            currentView = viewName;
            
            // 更新按钮状态
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === viewName);
            });
            
            // 设置相机位置 (Z轴向上)
            const distance = 6;
            camera.up.set(0, 0, 1);  // 确保Z轴向上
            
            switch (viewName) {
                case '3d':
                    camera.position.set(5, -5, 4);
                    controls.target.set(0, 0, 1.5);
                    break;
                case 'top':
                    // 俯视图: 从Z轴正方向往下看，看到X-Y平面
                    camera.position.set(0, 0, distance + 2);
                    controls.target.set(0, 0, 0);
                    break;
                case 'side':
                    // 侧视图: 从X轴方向看，Y轴水平，Z轴垂直
                    camera.position.set(distance, 0, 1.5);
                    controls.target.set(0, 0, 1.5);
                    break;
                case 'front':
                    // 正视图: 从Y轴负方向看，X轴水平，Z轴垂直
                    camera.position.set(0, -distance, 1.5);
                    controls.target.set(0, 0, 1.5);
                    break;
            }
            
            controls.update();
        }
        
        // 窗口大小调整
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            
            drawSpeedChart();
            drawComChart();
            drawJointChart();
        }
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            // 让释放点标记始终面向相机
            if (releaseMarker && releaseMarker.star) {
                releaseMarker.star.lookAt(camera.position);
            }
            
            // 让当前点标记的环始终面向相机
            if (currentPointMarker && currentPointMarker.children[0]) {
                currentPointMarker.children[0].lookAt(camera.position);
            }
            
            renderer.render(scene, camera);
        }
        
        // ============ 技术阶段面板功能 ============
        
        // 初始化阶段面板
        function initPhasePanel() {
            // 自动划分按钮
            document.getElementById('auto-phase-btn').addEventListener('click', () => {
                applyAutoPhases();
            });
            
            // 手动划分按钮
            document.getElementById('manual-phase-btn').addEventListener('click', () => {
                startManualMode();
            });
            
            // 重置按钮
            document.getElementById('phase-reset-btn').addEventListener('click', () => {
                resetPhases();
            });
            
            // 添加阶段按钮
            document.getElementById('phase-add-btn').addEventListener('click', () => {
                openPhaseDialog();
            });
            
            // 对话框取消按钮
            document.getElementById('phase-dialog-cancel').addEventListener('click', () => {
                closePhaseDialog();
            });
            
            // 对话框确认按钮
            document.getElementById('phase-dialog-confirm').addEventListener('click', () => {
                savePhaseFromDialog();
            });
            
            // 颜色选择
            document.querySelectorAll('.phase-color-option').forEach(opt => {
                opt.addEventListener('click', () => {
                    document.querySelectorAll('.phase-color-option').forEach(o => o.classList.remove('selected'));
                    opt.classList.add('selected');
                    selectedPhaseColor = opt.dataset.color;
                });
            });
            
            // 点击遮罩关闭对话框
            document.getElementById('phase-dialog-overlay').addEventListener('click', (e) => {
                if (e.target.id === 'phase-dialog-overlay') {
                    closePhaseDialog();
                }
            });
        }
        
        // 应用自动检测的阶段
        function applyAutoPhases() {
            if (!autoPhases || autoPhases.length === 0) {
                alert('没有检测到技术阶段数据');
                return;
            }
            
            phaseMode = 'auto';
            currentPhases = [...autoPhases];
            
            // 更新UI
            document.getElementById('phase-initial').style.display = 'none';
            document.getElementById('phase-list').style.display = 'flex';
            document.getElementById('phase-add-btn').style.display = 'none';
            document.getElementById('phase-actions').style.display = 'flex';
            
            renderPhaseList();
            updateTimelinePhaseColors();
        }
        
        // 开始手动模式
        function startManualMode() {
            phaseMode = 'manual';
            currentPhases = [...manualPhases];
            
            // 更新UI
            document.getElementById('phase-initial').style.display = 'none';
            document.getElementById('phase-list').style.display = 'flex';
            document.getElementById('phase-add-btn').style.display = 'block';
            document.getElementById('phase-actions').style.display = 'flex';
            
            renderPhaseList();
            updateTimelinePhaseColors();
        }
        
        // 重置阶段
        function resetPhases() {
            phaseMode = null;
            currentPhases = [];
            
            // 更新UI
            document.getElementById('phase-initial').style.display = 'block';
            document.getElementById('phase-list').style.display = 'none';
            document.getElementById('phase-add-btn').style.display = 'none';
            document.getElementById('phase-actions').style.display = 'none';
            
            updateTimelinePhaseColors();
        }
        
        // 渲染阶段列表
        function renderPhaseList() {
            const container = document.getElementById('phase-list');
            container.innerHTML = '';
            
            currentPhases.forEach((phase, index) => {
                const item = document.createElement('div');
                item.className = 'phase-item';
                item.dataset.phaseId = phase.id;
                
                const duration = (phase.end_time - phase.start_time).toFixed(3);
                
                item.innerHTML = `
                    <div class="phase-color" style="background:${phase.color}"></div>
                    <div class="phase-info">
                        <div class="phase-name">
                            ${phase.name}
                            ${phase.name_en ? `<span class="phase-name-en">(${phase.name_en})</span>` : ''}
                        </div>
                        <div class="phase-time">
                            ${phase.start_time.toFixed(3)}s - ${phase.end_time.toFixed(3)}s
                            <span class="phase-duration">${duration}s</span>
                        </div>
                    </div>
                    ${phaseMode === 'manual' ? `
                        <div class="phase-item-actions">
                            <button class="phase-item-btn edit" title="编辑">✏️</button>
                            <button class="phase-item-btn delete" title="删除">🗑️</button>
                        </div>
                    ` : ''}
                `;
                
                // 点击跳转到该阶段
                item.addEventListener('click', (e) => {
                    // 检查是否点击了编辑/删除按钮
                    const isActionBtn = e.target.classList && e.target.classList.contains('phase-item-btn');
                    if (!isActionBtn) {
                        jumpToPhase(phase);
                    }
                });
                
                // 双击设置播放范围
                item.addEventListener('dblclick', () => {
                    setPlaybackRangeToPhase(phase);
                });
                
                // 手动模式下的编辑和删除按钮
                if (phaseMode === 'manual') {
                    const editBtn = item.querySelector('.edit');
                    const deleteBtn = item.querySelector('.delete');
                    
                    if (editBtn) {
                        editBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            openPhaseDialog(phase);
                        });
                    }
                    
                    if (deleteBtn) {
                        deleteBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            deletePhase(phase.id);
                        });
                    }
                }
                
                container.appendChild(item);
            });
            
            // 添加"设置为出手点"按钮逻辑（按钮元素已在HTML中静态定义）
            if (discusData && !isPlaying) {
                 // 确保按钮可见
                 const setReleaseBtn = document.getElementById('set-release-btn-container');
                 if (setReleaseBtn) {
                     setReleaseBtn.style.display = 'flex';
                     setReleaseBtn.style.alignItems = 'center';
                     
                     // 确保只绑定一次事件
                     const btn = document.getElementById('set-current-frame-release');
                     if (btn && !btn.dataset.bound) {
                        btn.addEventListener('click', () => {
                            setManualReleasePoint();
                        });
                        
                        // 添加悬停效果
                        btn.addEventListener('mouseenter', () => {
                            btn.style.background = '#f1f5f9';
                            btn.style.borderColor = '#3b82f6';
                            btn.style.color = '#3b82f6';
                        });
                        
                        btn.addEventListener('mouseleave', () => {
                            btn.style.background = '#f8fafc';
                            btn.style.borderColor = '#e2e8f0';
                            btn.style.color = '#64748b';
                        });
                        
                        btn.dataset.bound = 'true';
                     }
                 }
            }
        }
        
        // 手动设置出手点
        function setManualReleasePoint() {
            if (!discusData || !comData || currentFrameIndex < 0) return;
            
            const frameIdx = currentFrameIndex;
            const time = discusData.times[frameIdx];
            
            if (confirm(`确定将当前帧 (帧 ${frameIdx}, 时间 ${time.toFixed(3)}s) 设为出手点并重新计算数据吗？`)) {
                
                // 构建新的 releasePoint 对象
                const newReleasePoint = {
                    index: frameIdx,
                    position: discusData.positions[frameIdx],
                    speed: discusData.speeds[frameIdx],
                    time: time
                };
                
                console.log('手动设置释放点:', newReleasePoint);
                
                // 重新计算生物力学指标
                const newBiomechanics = calculateBiomechanics(discusData, comData, newReleasePoint);
                console.log('新计算的生物力学指标:', newBiomechanics);
                
                // 更新全局变量
                if (window.analysisResult) {
                    window.analysisResult.release_point = newReleasePoint;
                    window.analysisResult.biomechanics = newBiomechanics;
                }
                
                // 更新页面全局变量
                releasePoint = newReleasePoint;
                biomechanics = newBiomechanics;
                
                // 重新渲染UI (使用 setTimeout 确保在 alert 之前或者之后都能渲染)
                requestAnimationFrame(() => {
                    updateDataPanel();
                    drawSpeedChart();
                    drawComChart();
                });
                
                // 提示成功
                setTimeout(() => {
                    alert(`已更新出手点！\n出手速度: ${newBiomechanics.release_velocity.toFixed(2)} m/s\n出手高度: ${newBiomechanics.release_height.toFixed(2)} m`);
                }, 100);
            }
        }
        
        // 跳转到指定阶段
        function jumpToPhase(phase) {
            if (!discusData) return;
            
            // 找到对应的帧
            const targetFrame = phase.start_frame || 
                discusData.times.findIndex(t => t >= phase.start_time);
            
            if (targetFrame >= 0) {
                updateCurrentPoint(targetFrame);
            }
            
            // 高亮当前阶段
            document.querySelectorAll('.phase-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.phaseId === phase.id) {
                    item.classList.add('active');
                }
            });
        }
        
        // 设置播放范围为指定阶段
        function setPlaybackRangeToPhase(phase) {
            if (!discusData) return;
            
            const startIdx = phase.start_frame || 
                discusData.times.findIndex(t => t >= phase.start_time);
            const endIdx = phase.end_frame || 
                discusData.times.findIndex(t => t >= phase.end_time);
            
            if (startIdx >= 0 && endIdx >= 0) {
                startFrame = startIdx;
                endFrame = endIdx;
                
                document.getElementById('start-frame-input').value = startFrame;
                document.getElementById('end-frame-input').value = endFrame;
                
                updateMarkerPositions();
                
                // 如果启用了范围裁剪，重新绘制
                if (rangeClipEnabled) {
                    updateRangeTrajectory();
                }
            }
        }
        
        // 打开阶段编辑对话框
        function openPhaseDialog(phase = null) {
            const overlay = document.getElementById('phase-dialog-overlay');
            const title = document.getElementById('phase-dialog-title');
            const nameInput = document.getElementById('phase-name-input');
            const startInput = document.getElementById('phase-start-input');
            const endInput = document.getElementById('phase-end-input');
            
            if (phase) {
                // 编辑模式
                editingPhaseId = phase.id;
                title.textContent = '编辑技术阶段';
                nameInput.value = phase.name;
                startInput.value = phase.start_time;
                endInput.value = phase.end_time;
                
                // 选中对应颜色
                document.querySelectorAll('.phase-color-option').forEach(opt => {
                    opt.classList.toggle('selected', opt.dataset.color === phase.color);
                    if (opt.dataset.color === phase.color) {
                        selectedPhaseColor = phase.color;
                    }
                });
            } else {
                // 新增模式
                editingPhaseId = null;
                title.textContent = '添加技术阶段';
                nameInput.value = '';
                startInput.value = discusData ? discusData.times[currentIndex].toFixed(3) : '0';
                endInput.value = discusData ? discusData.times[Math.min(currentIndex + 100, discusData.times.length - 1)].toFixed(3) : '1';
                
                // 默认选第一个颜色
                document.querySelectorAll('.phase-color-option').forEach((opt, i) => {
                    opt.classList.toggle('selected', i === 0);
                });
                selectedPhaseColor = '#22c55e';
            }
            
            overlay.classList.add('active');
        }
        
        // 关闭阶段编辑对话框
        function closePhaseDialog() {
            document.getElementById('phase-dialog-overlay').classList.remove('active');
            editingPhaseId = null;
        }
        
        // 从对话框保存阶段
        function savePhaseFromDialog() {
            const name = document.getElementById('phase-name-input').value.trim();
            const startTime = parseFloat(document.getElementById('phase-start-input').value);
            const endTime = parseFloat(document.getElementById('phase-end-input').value);
            
            if (!name) {
                alert('请输入阶段名称');
                return;
            }
            
            if (isNaN(startTime) || isNaN(endTime)) {
                alert('请输入有效的时间');
                return;
            }
            
            if (startTime >= endTime) {
                alert('结束时间必须大于开始时间');
                return;
            }
            
            // 计算帧索引
            const startFrame = discusData ? 
                discusData.times.findIndex(t => t >= startTime) : 0;
            const endFrame = discusData ? 
                discusData.times.findIndex(t => t >= endTime) : 0;
            
            if (editingPhaseId) {
                // 编辑现有阶段
                const index = manualPhases.findIndex(p => p.id === editingPhaseId);
                if (index >= 0) {
                    manualPhases[index] = {
                        ...manualPhases[index],
                        name,
                        start_time: startTime,
                        end_time: endTime,
                        start_frame: startFrame,
                        end_frame: endFrame,
                        color: selectedPhaseColor
                    };
                }
            } else {
                // 新增阶段
                const newPhase = {
                    id: 'manual_' + Date.now(),
                    name,
                    name_en: '',
                    start_time: startTime,
                    end_time: endTime,
                    start_frame: startFrame,
                    end_frame: endFrame,
                    color: selectedPhaseColor,
                    metrics: {
                        duration: endTime - startTime
                    }
                };
                manualPhases.push(newPhase);
            }
            
            // 按开始时间排序
            manualPhases.sort((a, b) => a.start_time - b.start_time);
            
            // 保存到localStorage
            saveManualPhases();
            
            // 更新当前阶段列表
            currentPhases = [...manualPhases];
            
            // 重新渲染
            renderPhaseList();
            updateTimelinePhaseColors();
            
            // 关闭对话框
            closePhaseDialog();
        }
        
        // 删除阶段
        function deletePhase(phaseId) {
            if (!confirm('确定要删除这个阶段吗？')) return;
            
            manualPhases = manualPhases.filter(p => p.id !== phaseId);
            currentPhases = [...manualPhases];
            
            saveManualPhases();
            renderPhaseList();
            updateTimelinePhaseColors();
        }
        
        // 保存手动阶段到localStorage
        function saveManualPhases() {
            localStorage.setItem('discus_manual_phases', JSON.stringify(manualPhases));
        }
        
        // 从localStorage加载手动阶段
        function loadManualPhases() {
            try {
                const saved = localStorage.getItem('discus_manual_phases');
                if (saved) {
                    manualPhases = JSON.parse(saved);
                }
            } catch (e) {
                console.error('加载手动阶段失败:', e);
                manualPhases = [];
            }
        }
        
        // 更新时间轴阶段颜色条
        function updateTimelinePhaseColors() {
            const container = document.getElementById('phase-color-bar');
            if (!container) return;
            
            container.innerHTML = '';
            
            if (!currentPhases || currentPhases.length === 0 || !discusData) {
                return;
            }
            
            const totalTime = discusData.times[discusData.times.length - 1] - discusData.times[0];
            const startTime = discusData.times[0];
            
            currentPhases.forEach(phase => {
                const segment = document.createElement('div');
                segment.className = 'phase-color-segment';
                
                // 计算宽度百分比
                const duration = phase.end_time - phase.start_time;
                const widthPercent = (duration / totalTime) * 100;
                
                // 计算左边距（如果第一个阶段不从0开始）
                const offsetPercent = ((phase.start_time - startTime) / totalTime) * 100;
                
                segment.style.width = widthPercent + '%';
                segment.style.marginLeft = (phase === currentPhases[0] ? offsetPercent : 0) + '%';
                segment.style.background = phase.color;
                segment.dataset.tooltip = `${phase.name}: ${phase.start_time.toFixed(2)}s - ${phase.end_time.toFixed(2)}s`;
                segment.dataset.phaseId = phase.id;
                
                // 总是显示阶段名称，如果宽度太小就只显示前两个字
                const label = document.createElement('span');
                label.className = 'phase-label';
                if (widthPercent < 6) {
                    // 宽度很小，只显示前两个字
                    label.textContent = phase.name.substring(0, 2);
                } else if (widthPercent < 10) {
                    // 宽度较小，显示前两个字
                    label.textContent = phase.name.substring(0, 2);
                } else {
                    // 宽度足够，显示完整名称
                    label.textContent = phase.name;
                }
                segment.appendChild(label);
                
                // 点击跳转到该阶段
                segment.addEventListener('click', () => {
                    jumpToPhase(phase);
                });
                
                // 双击设置播放范围
                segment.addEventListener('dblclick', () => {
                    setPlaybackRangeToPhase(phase);
                });
                
                container.appendChild(segment);
            });
        }
        
        // ============ 数据导入功能 ============
        let selectedFile = null;
        
        // 动态列索引（将在解析文件时自动检测）
        let COL_TIME = 0;
        let COL_COG_X = -1, COL_COG_Y = -1, COL_COG_Z = -1;
        let COL_COG_VX = -1, COL_COG_VY = -1, COL_COG_VZ = -1, COL_COG_V = -1;
        let COL_HAND_R_X = -1, COL_HAND_R_Y = -1, COL_HAND_R_Z = -1;
        let COL_HAND_R_VX = -1, COL_HAND_R_VY = -1, COL_HAND_R_VZ = -1, COL_HAND_R_V = -1;
        
        // 动态骨架关节点列索引
        let SKELETON_JOINTS_IDX = {};
        
        // 字段名映射表（用于自动检测）
        const FIELD_PATTERNS = {
            // 重心相关
            'COG_X': ['CenterOfGravity X', '/Calc/CenterOfGravity X'],
            'COG_Y': ['CenterOfGravity Y', '/Calc/CenterOfGravity Y'],
            'COG_Z': ['CenterOfGravity Z', '/Calc/CenterOfGravity Z'],
            'COG_VX': ['CenterOfGravity v(X)', '/Calc/CenterOfGravity v(X)'],
            'COG_VY': ['CenterOfGravity v(Y)', '/Calc/CenterOfGravity v(Y)'],
            'COG_VZ': ['CenterOfGravity v(Z)', '/Calc/CenterOfGravity v(Z)'],
            'COG_V': ['CenterOfGravity v(绝对值)', '/Calc/CenterOfGravity v(绝对值)'],
            // 右手（铁饼）相关
            'HAND_R_X': ['Hand/Index/Base/Right X', '/Feature/Hand/Index/Base/Right X'],
            'HAND_R_Y': ['Hand/Index/Base/Right Y', '/Feature/Hand/Index/Base/Right Y'],
            'HAND_R_Z': ['Hand/Index/Base/Right Z', '/Feature/Hand/Index/Base/Right Z'],
            'HAND_R_VX': ['Hand/Index/Base/Right v(X)', '/Feature/Hand/Index/Base/Right v(X)'],
            'HAND_R_VY': ['Hand/Index/Base/Right v(Y)', '/Feature/Hand/Index/Base/Right v(Y)'],
            'HAND_R_VZ': ['Hand/Index/Base/Right v(Z)', '/Feature/Hand/Index/Base/Right v(Z)'],
            'HAND_R_V': ['Hand/Index/Base/Right v(绝对值)', '/Feature/Hand/Index/Base/Right v(绝对值)'],
        };
        
        // 骨架关节点字段名映射
        const SKELETON_FIELD_PATTERNS = {
            'root': ['/Joint/Root X'],
            'pelvis': ['/Joint/Hip/Center X', '/Joint/Pelvis X'],
            'spine_low': ['/Joint/Spine/Lower X', '/Joint/Spine/Low X', '/Feature/Spine/Low X'],
            'spine_high': ['/Joint/Spine/Upper X', '/Joint/Spine/High X', '/Feature/Spine/High X'],
            'torso': ['/Joint/Torso X', '/Joint/Chest X'],
            'neck': ['/Joint/Neck X'],
            'head': ['/Joint/Head X', '/Joint/Skullbase X'],
            'clavicle_r': ['/Joint/Clavicle/Right X', '/Feature/Clavicle/Right X', '/Joint/Clavicular/Right X'],
            'shoulder_r': ['/Joint/Shoulder/Right X'],
            'elbow_r': ['/Joint/Elbow/Right X'],
            'wrist_r': ['/Joint/Wrist/Right X'],
            'hand_index_r': ['/Feature/Hand/Index/Base/Right X'],
            'hand_little_r': ['/Feature/Hand/Little/Base/Right X'],
            'clavicle_l': ['/Joint/Clavicle/Left X', '/Feature/Clavicle/Left X', '/Joint/Clavicular/Left X'],
            'shoulder_l': ['/Joint/Shoulder/Left X'],
            'elbow_l': ['/Joint/Elbow/Left X'],
            'wrist_l': ['/Joint/Wrist/Left X'],
            'hand_index_l': ['/Feature/Hand/Index/Base/Left X'],
            'hand_little_l': ['/Feature/Hand/Little/Base/Left X'],
            'hip_r': ['/Joint/Hip/Right X'],
            'knee_r': ['/Joint/Knee/Right X'],
            'ankle_r': ['/Joint/Ankle/Right X'],
            'foot_r': ['/Joint/Foot/Right X', '/Feature/Foot/Right X', '/Joint/Midfoot/Right X'],
            'hip_l': ['/Joint/Hip/Left X'],
            'knee_l': ['/Joint/Knee/Left X'],
            'ankle_l': ['/Joint/Ankle/Left X'],
            'foot_l': ['/Joint/Foot/Left X', '/Feature/Foot/Left X', '/Joint/Midfoot/Left X'],
        };
        
        // 自动检测字段位置
        // sampleDataRow: 可选的数据行，用于验证哪组数据是正确的（通过检查Z坐标合理性）
        function detectFieldPositions(headerRow, sampleDataRow = null) {
            const detected = {
                success: true,
                fields: {},
                skeletonJoints: {},
                missing: [],
                found: []
            };
            
            // 辅助函数：找到所有匹配的列索引
            function findAllMatches(pattern) {
                const matches = [];
                for (let i = 0; i < headerRow.length; i++) {
                    if (headerRow[i].includes(pattern) || headerRow[i] === pattern) {
                        matches.push(i);
                    }
                }
                return matches;
            }
            
            // 辅助函数：选择Z坐标合理的数据组（人体坐标Z应该在0-2.5米之间）
            function selectValidIndex(matches, isZColumn = false) {
                if (matches.length === 0) return -1;
                if (matches.length === 1 || !sampleDataRow) return matches[0];
                
                // 如果有多组匹配，检查对应的Z坐标值（X列+2=Z列）
                for (const idx of matches) {
                    const zIdx = idx + 2; // X列+2=Z列
                    if (zIdx < sampleDataRow.length) {
                        const zValue = parseFloat(sampleDataRow[zIdx]);
                        // 正常人体坐标，Z值应该在0-2.5米之间
                        if (!isNaN(zValue) && zValue >= 0 && zValue <= 2.5) {
                            return idx;
                        }
                    }
                }
                // 如果都不合理，返回第一个
                return matches[0];
            }
            
            // 检测基础字段 - 智能选择正确的数据组
            for (const [fieldKey, patterns] of Object.entries(FIELD_PATTERNS)) {
                let foundIndex = -1;
                for (const pattern of patterns) {
                    const matches = findAllMatches(pattern);
                    if (matches.length > 0) {
                        foundIndex = selectValidIndex(matches);
                        break;
                    }
                }
                detected.fields[fieldKey] = foundIndex;
                if (foundIndex === -1) {
                    detected.missing.push(fieldKey);
                } else {
                    detected.found.push(`${fieldKey}: 列${foundIndex}`);
                }
            }
            
            // 检测骨架关节点 - 智能选择正确的数据组
            for (const [jointName, patterns] of Object.entries(SKELETON_FIELD_PATTERNS)) {
                let foundIndex = -1;
                for (const pattern of patterns) {
                    const matches = findAllMatches(pattern);
                    if (matches.length > 0) {
                        foundIndex = selectValidIndex(matches);
                        break;
                    }
                }
                detected.skeletonJoints[jointName] = foundIndex;
                if (foundIndex === -1) {
                    // 骨架关节缺失不算严重错误，只是警告
                    console.warn(`骨架关节 ${jointName} 未找到`);
                }
            }
            
            // 检查关键字段是否存在
            const criticalFields = ['HAND_R_X', 'HAND_R_Y', 'HAND_R_Z'];
            const missingCritical = criticalFields.filter(f => detected.fields[f] === -1);
            if (missingCritical.length > 0) {
                detected.success = false;
            }
            
            return detected;
        }
        
        // 应用检测到的字段位置
        function applyDetectedPositions(detected) {
            // 应用基础字段
            COL_COG_X = detected.fields['COG_X'];
            COL_COG_Y = detected.fields['COG_Y'];
            COL_COG_Z = detected.fields['COG_Z'];
            COL_COG_VX = detected.fields['COG_VX'];
            COL_COG_VY = detected.fields['COG_VY'];
            COL_COG_VZ = detected.fields['COG_VZ'];
            COL_COG_V = detected.fields['COG_V'];
            COL_HAND_R_X = detected.fields['HAND_R_X'];
            COL_HAND_R_Y = detected.fields['HAND_R_Y'];
            COL_HAND_R_Z = detected.fields['HAND_R_Z'];
            COL_HAND_R_VX = detected.fields['HAND_R_VX'];
            COL_HAND_R_VY = detected.fields['HAND_R_VY'];
            COL_HAND_R_VZ = detected.fields['HAND_R_VZ'];
            COL_HAND_R_V = detected.fields['HAND_R_V'];
            
            // 应用骨架关节点
            SKELETON_JOINTS_IDX = detected.skeletonJoints;
            
            console.log('字段位置检测完成:', {
                COG: { X: COL_COG_X, Y: COL_COG_Y, Z: COL_COG_Z },
                HAND_R: { X: COL_HAND_R_X, Y: COL_HAND_R_Y, Z: COL_HAND_R_Z },
                骨架关节数: Object.keys(SKELETON_JOINTS_IDX).filter(k => SKELETON_JOINTS_IDX[k] !== -1).length
            });
        }
        
        const SKELETON_BONES_DEF = [
            ['pelvis', 'spine_low'], ['spine_low', 'spine_high'], ['spine_high', 'torso'],
            ['torso', 'neck'], ['neck', 'head'],
            ['torso', 'clavicle_r'], ['clavicle_r', 'shoulder_r'], ['shoulder_r', 'elbow_r'],
            ['elbow_r', 'wrist_r'], ['wrist_r', 'hand_index_r'], ['wrist_r', 'hand_little_r'],
            ['hand_index_r', 'hand_little_r'],
            ['torso', 'clavicle_l'], ['clavicle_l', 'shoulder_l'], ['shoulder_l', 'elbow_l'],
            ['elbow_l', 'wrist_l'], ['wrist_l', 'hand_index_l'], ['wrist_l', 'hand_little_l'],
            ['hand_index_l', 'hand_little_l'],
            ['pelvis', 'hip_r'], ['hip_r', 'knee_r'], ['knee_r', 'ankle_r'], ['ankle_r', 'foot_r'],
            ['pelvis', 'hip_l'], ['hip_l', 'knee_l'], ['knee_l', 'ankle_l'], ['ankle_l', 'foot_l'],
        ];
        
        // 检测是否为均匀行（所有值几乎相同的参数/元数据行）
        function isUniformRow(row) {
            const sampleSize = Math.min(50, row.length);
            const vals = [];
            for (let i = 0; i < sampleSize; i++) {
                const v = typeof row[i] === 'string' ? parseFloat(row[i]) : row[i];
                if (!isNaN(v)) vals.push(v);
            }
            if (vals.length < 10) return false;
            const firstVal = vals[0];
            const sameCount = vals.filter(v => Math.abs(v - firstVal) < 0.001).length;
            return sameCount > vals.length * 0.8;
        }
        
        // 查找有效的样本数据行（跳过header、参数行和均匀行）
        function findValidSampleRow(lines, maxSearch = 20) {
            for (let i = 1; i < Math.min(lines.length, maxSearch); i++) {
                const row = lines[i].trim().split('\t');
                if (row.length > 10 && !isNaN(parseFloat(row[0])) && parseFloat(row[0]) > 0) {
                    if (!isUniformRow(row)) {
                        return row;
                    }
                }
            }
            return null;
        }
        
        // 解析动捕txt文件
        function parseMotionCaptureFile(content, progressCallback) {
            const lines = content.split('\n');
            const rawData = [];
            
            // 跳过前两行（标题和参数行），从第3行开始
            for (let i = 2; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const parts = line.split('\t');
                if (parts.length > 100) {
                    try {
                        const values = parts.map(x => x ? parseFloat(x) : 0.0);
                        if (values[0] > 0) { // 有效时间戳
                            // 检测"均匀行"：如果一行中绝大多数值都相同，则为参数/元数据行
                            const sampleValues = values.slice(0, Math.min(50, values.length));
                            const firstVal = sampleValues[0];
                            const sameCount = sampleValues.filter(v => Math.abs(v - firstVal) < 0.001).length;
                            if (sameCount > sampleValues.length * 0.8) {
                                console.log(`跳过均匀行 (行${i+1}): 所有值≈${firstVal.toFixed(4)}`);
                                continue;
                            }
                            rawData.push(values);
                        }
                    } catch (e) {
                        continue;
                    }
                }
                
                // 更新进度
                if (progressCallback && i % 50 === 0) {
                    progressCallback(Math.round((i / lines.length) * 30));
                }
            }
            
            // 确保时间戳严格递增，过滤掉时间回退的行
            const data = [];
            let lastTime = -Infinity;
            for (const row of rawData) {
                if (row[0] > lastTime) {
                    data.push(row);
                    lastTime = row[0];
                } else {
                    console.log(`跳过时间回退行: t=${row[0].toFixed(4)}, 上一有效时间=${lastTime.toFixed(4)}`);
                }
            }
            
            if (rawData.length !== data.length) {
                console.log(`数据清洗: ${rawData.length} → ${data.length} 行 (移除 ${rawData.length - data.length} 行无效数据)`);
            }
            
            return data;
        }
        
        // 提取铁饼轨迹数据
        function extractDiscusTrajectory(data, progressCallback) {
            const times = [], positions = [], velocities = [], speeds = [];
            
            for (let i = 0; i < data.length; i++) {
                const row = data[i];
                const t = row[COL_TIME];
                const x = row[COL_HAND_R_X], y = row[COL_HAND_R_Y], z = row[COL_HAND_R_Z];
                const vx = row[COL_HAND_R_VX], vy = row[COL_HAND_R_VY], vz = row[COL_HAND_R_VZ];
                const v = row[COL_HAND_R_V];
                
                if (Math.abs(x) < 0.01 && Math.abs(y) < 0.01 && Math.abs(z) < 0.01) continue;
                
                times.push(t);
                positions.push([x, y, z]);
                velocities.push([vx, vy, vz]);
                speeds.push(v);
                
                if (progressCallback && i % 50 === 0) {
                    progressCallback(30 + Math.round((i / data.length) * 15));
                }
            }
            
            return { times, positions, velocities, speeds };
        }
        
        // 提取重心轨迹
        function extractComTrajectory(data, progressCallback) {
            const times = [], positions = [], speeds = [];
            
            // 检查列索引是否有效
            const hasCog = COL_COG_X !== -1 && COL_COG_Y !== -1 && COL_COG_Z !== -1;
            
            for (let i = 0; i < data.length; i++) {
                const row = data[i];
                times.push(row[COL_TIME]);
                
                if (hasCog) {
                    positions.push([row[COL_COG_X] || 0, row[COL_COG_Y] || 0, row[COL_COG_Z] || 0]);
                    speeds.push(COL_COG_V !== -1 ? (row[COL_COG_V] || 0) : 0);
                } else {
                    positions.push([0, 0, 0]);
                    speeds.push(0);
                }
                
                if (progressCallback && i % 50 === 0) {
                    progressCallback(45 + Math.round((i / data.length) * 10));
                }
            }
            
            return { times, positions, speeds };
        }
        
        // 提取骨架数据
        function extractSkeletonData(data, progressCallback) {
            const frames = [];
            
            // 过滤出有效的关节点（列索引不为-1）
            const validJoints = Object.entries(SKELETON_JOINTS_IDX).filter(([name, idx]) => idx !== -1);
            
            for (let i = 0; i < data.length; i++) {
                const row = data[i];
                const frameJoints = {};
                
                for (const [jointName, colIdx] of validJoints) {
                    try {
                        if (colIdx !== -1 && colIdx + 2 < row.length) {
                            frameJoints[jointName] = [row[colIdx] || 0, row[colIdx + 1] || 0, row[colIdx + 2] || 0];
                        } else {
                            frameJoints[jointName] = [0, 0, 0];
                        }
                    } catch (e) {
                        frameJoints[jointName] = [0, 0, 0];
                    }
                }
                frames.push(frameJoints);
                
                if (progressCallback && i % 50 === 0) {
                    progressCallback(55 + Math.round((i / data.length) * 15));
                }
            }
            
            // 只返回有效的关节名称
            const validJointNames = validJoints.map(([name, idx]) => name);
            
            return {
                frames,
                bones: SKELETON_BONES_DEF,
                joint_names: validJointNames
            };
        }
        
        // 提取关节速度数据
        function extractJointSpeeds(data) {
            const jointSpeedsResult = {};
            const jointNamesCn = {
                'root': '根节点', 'pelvis': '骨盆', 'spine_low': '下脊柱', 'spine_high': '上脊柱',
                'torso': '躯干', 'neck': '颈部', 'head': '头部',
                'clavicle_r': '右锁骨', 'shoulder_r': '右肩', 'elbow_r': '右肘', 'wrist_r': '右腕',
                'hand_index_r': '右手食指', 'hand_little_r': '右手小指',
                'clavicle_l': '左锁骨', 'shoulder_l': '左肩', 'elbow_l': '左肘', 'wrist_l': '左腕',
                'hand_index_l': '左手食指', 'hand_little_l': '左手小指',
                'hip_r': '右髋', 'knee_r': '右膝', 'ankle_r': '右踝', 'foot_r': '右脚',
                'hip_l': '左髋', 'knee_l': '左膝', 'ankle_l': '左踝', 'foot_l': '左脚',
            };
            
            for (const [jointName, colIdx] of Object.entries(SKELETON_JOINTS_IDX)) {
                // 跳过无效的列索引
                if (colIdx === -1) continue;
                
                const speeds = [];
                const speedCol = colIdx + 7;
                
                for (const row of data) {
                    try {
                        speeds.push(speedCol < row.length ? (row[speedCol] || 0) : 0);
                    } catch (e) {
                        speeds.push(0);
                    }
                }
                
                jointSpeedsResult[jointName] = {
                    speeds,
                    name_cn: jointNamesCn[jointName] || jointName,
                    max_speed: Math.max(...speeds),
                    avg_speed: speeds.reduce((a, b) => a + b, 0) / speeds.length
                };
            }
            
            return jointSpeedsResult;
        }
        
        // 计算三点角度 (p1-p2-p3, p2为顶点)
        function calculateAngle(p1, p2, p3) {
            if (!p1 || !p2 || !p3) return 0;
            
            // 向量 v1: p2 -> p1
            const v1 = { x: p1[0]-p2[0], y: p1[1]-p2[1], z: p1[2]-p2[2] };
            // 向量 v2: p2 -> p3
            const v2 = { x: p3[0]-p2[0], y: p3[1]-p2[1], z: p3[2]-p2[2] };
            
            const dot = v1.x*v2.x + v1.y*v2.y + v1.z*v2.z;
            const norm1 = Math.sqrt(v1.x*v1.x + v1.y*v1.y + v1.z*v1.z);
            const norm2 = Math.sqrt(v2.x*v2.x + v2.y*v2.y + v2.z*v2.z);
            
            if (norm1 === 0 || norm2 === 0) return 0;
            
            let cosAngle = dot / (norm1 * norm2);
            cosAngle = Math.max(-1.0, Math.min(1.0, cosAngle));
            
            return Math.acos(cosAngle) * 180 / Math.PI;
        }

        // 找到释放点
        function findReleasePoint(discusDataLocal, skeletonDataLocal = null) {
            const speeds = discusDataLocal.speeds;
            const positions = discusDataLocal.positions;
            const velocities = discusDataLocal.velocities;
            const times = discusDataLocal.times;
            const n = speeds.length;
            
            // 跳过开头的边界伪影帧
            const skipStart = Math.max(5, Math.floor(n * 0.10));
            const skipEnd = Math.max(3, Math.floor(n * 0.02));
            const searchEnd = n - skipEnd;

            // 在有效范围内找全局最大速度（用于阈值参考）
            let globalMaxSpeed = 0;
            for (let i = skipStart; i < searchEnd; i++) {
                if (speeds[i] > globalMaxSpeed) globalMaxSpeed = speeds[i];
            }
            
            // 智能判断项目类型：铅球速度通常 < 16m/s，铁饼通常 > 20m/s
            // 如果最大速度小于 18m/s，倾向于是铅球，要求更高的出手高度
            const isShotPut = globalMaxSpeed < 18.0;
            const MIN_RELEASE_HEIGHT = isShotPut ? 1.6 : 1.2;
            
            console.log(`项目类型推断: ${isShotPut ? '铅球(Shot Put)' : '铁饼(Discus)'}, 最大速度=${globalMaxSpeed.toFixed(2)}m/s, 最小高度阈值=${MIN_RELEASE_HEIGHT}m`);
            
            // ====== 核心策略：找第一个显著速度局部峰值 ======
            // 投掷项目中，器械出手时手速达到局部峰值，之后短暂下降（失去负载），
            // 然后空手随动阶段手速可能再次上升。第一个峰值才是真正的出手点。
            
            // 先做简单平滑（5帧窗口），避免噪声干扰
            const smoothed = [];
            const halfWin = 2;
            for (let i = 0; i < n; i++) {
                let sum = 0, cnt = 0;
                for (let j = Math.max(0, i - halfWin); j <= Math.min(n - 1, i + halfWin); j++) {
                    sum += speeds[j]; cnt++;
                }
                smoothed.push(sum / cnt);
            }
            
            let releaseIdx = -1;
            
            // ====== 铅球专用逻辑：结合肘关节角度 ======
            if (isShotPut && skeletonDataLocal && skeletonDataLocal.frames) {
                console.log("应用铅球优化算法：寻找肘关节伸直且速度较大的点...");
                const candidates = [];
                const frames = skeletonDataLocal.frames;
                const nFrames = Math.min(frames.length, n);
                
                for (let i = skipStart; i < Math.min(searchEnd, nFrames); i++) {
                    const frame = frames[i];
                    // 检查是否有关节数据 (骨架提取时可能只存了 keypoint)
                    // 需要确认 extractSkeletonData 的返回结构
                    if (frame['shoulder_r'] && frame['elbow_r'] && frame['wrist_r']) {
                        const angle = calculateAngle(frame['shoulder_r'], frame['elbow_r'], frame['wrist_r']);
                        const height = positions[i][2];
                        const speed = speeds[i];
                        
                        // 筛选条件：高度达标，且肘关节接近伸直 (>130度)
                        // 增加条件：垂直速度必须大于0 (出手角度必须为正)
                        if (height > 1.6 && angle > 130 && velocities[i][2] > 0) {
                            candidates.push({
                                idx: i,
                                speed: speed,
                                height: height,
                                angle: angle,
                                vz: velocities[i][2]
                            });
                        }
                    }
                }
                
                if (candidates.length > 0) {
                    // 选择速度最大的点
                    candidates.sort((a, b) => b.speed - a.speed);
                    const best = candidates[0];
                    releaseIdx = best.idx;
                    console.log(`铅球释放点锁定: 帧${releaseIdx}, 速度=${best.speed.toFixed(2)}m/s, 高度=${best.height.toFixed(2)}m, 角度=${best.angle.toFixed(1)}°`);
                    
                    // 计算出手角度供日志输出
                    let angle = 0;
                    if (velocities && releaseIdx < velocities.length) {
                        const vel = velocities[releaseIdx];
                        const hv = Math.sqrt(vel[0]**2 + vel[1]**2);
                        angle = hv > 0 ? Math.atan2(vel[2], hv) * 180 / Math.PI : 0;
                    }
                    console.log(`释放点最终(铅球优化): 帧=${releaseIdx}, t=${times[releaseIdx].toFixed(3)}s, 速度=${speeds[releaseIdx].toFixed(2)}m/s, 高度=${positions[releaseIdx][2].toFixed(3)}m, 角度=${angle.toFixed(1)}°`);
                    
                    return {
                        index: releaseIdx,
                        position: positions[releaseIdx],
                        speed: speeds[releaseIdx],
                        time: times[releaseIdx]
                    };
                } else {
                    console.log("未找到满足铅球条件的释放点，回退到通用逻辑");
                }
            }
            
            // 在有效范围内找全局最大速度（用于阈值参考）
            // 注意：前面的代码块已经计算过 globalMaxSpeed 和 MIN_RELEASE_HEIGHT，这里不需要重复计算
            
            // 找所有局部速度峰值（平滑后）
            const peaks = [];
            for (let i = skipStart + 1; i < searchEnd - 1; i++) {
                // 必须是局部峰值
                if (smoothed[i] > smoothed[i - 1] && smoothed[i] >= smoothed[i + 1]) {
                    // 增加高度过滤：只有高度足够才可能是释放点
                    if (positions[i][2] > MIN_RELEASE_HEIGHT) {
                        peaks.push({ idx: i, speed: speeds[i], smoothedSpeed: smoothed[i], height: positions[i][2] });
                    }
                }
            }
            
            // 找第一个"显著"峰值：速度 >= 全局最大的40%，且之后有明显下降（至少10%）
            // let releaseIdx = -1; // Removed duplicate declaration
            const minPeakSpeed = globalMaxSpeed * 0.40;
            
            for (const peak of peaks) {
                if (peak.speed < minPeakSpeed) continue;
                
                // 检查峰值后是否有明显下降（在接下来10帧内速度下降至少10%）
                const lookAhead = Math.min(peak.idx + 10, searchEnd);
                let minAfter = peak.speed;
                for (let j = peak.idx + 1; j < lookAhead; j++) {
                    if (smoothed[j] < minAfter) minAfter = smoothed[j];
                }
                
                const dropRatio = (peak.speed - minAfter) / peak.speed;
                // 对于铅球，速度下降可能不如铁饼剧烈，适当降低阈值到 5%
                if (dropRatio > 0.05) { 
                    releaseIdx = peak.idx;
                    console.log(`释放点检测(局部峰值法): 帧${peak.idx}, 速度=${peak.speed.toFixed(2)}m/s, 高度=${peak.height.toFixed(2)}m, 峰后下降${(dropRatio*100).toFixed(1)}%`);
                    break;
                }
            }
            
            // 如果没找到合适的局部峰值，回退策略：
            // 在高度满足条件的点中，找速度最大的点
            if (releaseIdx === -1) {
                let bestIdx = -1;
                let maxVal = -1;
                
                for (let i = skipStart; i < searchEnd; i++) {
                    if (positions[i][2] > MIN_RELEASE_HEIGHT) {
                        if (speeds[i] > maxVal) {
                            maxVal = speeds[i];
                            bestIdx = i;
                        }
                    }
                }
                
                if (bestIdx !== -1) {
                    releaseIdx = bestIdx;
                    console.log(`释放点检测(高位最大速度法): 帧${bestIdx}, 速度=${maxVal.toFixed(2)}m/s`);
                } else {
                    // 实在找不到高位点，只能回退到全局最大速度
                    let maxSpeedIdx = skipStart;
                    for (let i = skipStart; i < searchEnd; i++) {
                        if (speeds[i] > speeds[maxSpeedIdx]) maxSpeedIdx = i;
                    }
                    releaseIdx = maxSpeedIdx;
                    console.log(`释放点检测(保底全局最大): 帧${releaseIdx}, 高度=${positions[releaseIdx][2].toFixed(2)}m (未满足高度阈值)`);
                }
                
                // 尝试从选定点微调：寻找真正的速度峰值（在选定点附近）
                // 有时候最大速度点可能稍微偏一点
                const range = 5;
                let refinedIdx = releaseIdx;
                let currentMaxSpeed = speeds[releaseIdx];
                
                for (let i = Math.max(skipStart, releaseIdx - range); i <= Math.min(searchEnd, releaseIdx + range); i++) {
                    // 微调时也要遵守高度限制，或者至少不能比原点低太多（例如允许降低 0.1m）
                    if (speeds[i] > currentMaxSpeed && positions[i][2] > MIN_RELEASE_HEIGHT - 0.1) {
                        refinedIdx = i;
                        currentMaxSpeed = speeds[i];
                    }
                }
                releaseIdx = refinedIdx;
            }
            
            // 计算出手角度供日志输出
            let angle = 0;
            if (velocities && releaseIdx < velocities.length) {
                const vel = velocities[releaseIdx];
                const hv = Math.sqrt(vel[0]**2 + vel[1]**2);
                angle = hv > 0 ? Math.atan2(vel[2], hv) * 180 / Math.PI : 0;
            }
            
            console.log(`释放点最终: 帧=${releaseIdx}, t=${times[releaseIdx].toFixed(3)}s, 速度=${speeds[releaseIdx].toFixed(2)}m/s, 高度=${positions[releaseIdx][2].toFixed(3)}m, 角度=${angle.toFixed(1)}°`);
            
            return {
                index: releaseIdx,
                position: positions[releaseIdx],
                speed: speeds[releaseIdx],
                time: times[releaseIdx]
            };
        }
        
        // 计算生物力学指标
        function calculateBiomechanics(discusDataLocal, comDataLocal, releasePointLocal) {
            const positions = discusDataLocal.positions;
            const speeds = discusDataLocal.speeds;
            const velocities = discusDataLocal.velocities;
            const times = discusDataLocal.times;
            
            const releaseIdx = releasePointLocal.index;
            const releasePos = releasePointLocal.position;
            const releaseVel = velocities[releaseIdx];
            
            // 出手速度
            const releaseVelocity = releasePointLocal.speed;
            
            // 出手高度
            const releaseHeight = releasePos[2];
            
            // 出手角度
            const horizontalV = Math.sqrt(releaseVel[0]**2 + releaseVel[1]**2);
            const releaseAngle = horizontalV > 0 ? 
                Math.atan2(releaseVel[2], horizontalV) * 180 / Math.PI : 35.0;
            
            // 旋转圈数估计
            const xyPositions = positions.slice(0, releaseIdx).map(p => [p[0], p[1]]);
            let rotationCount = 1.5;
            
            if (xyPositions.length > 10) {
                const centerX = xyPositions.reduce((s, p) => s + p[0], 0) / xyPositions.length;
                const centerY = xyPositions.reduce((s, p) => s + p[1], 0) / xyPositions.length;
                
                const angles = xyPositions.map(p => Math.atan2(p[1] - centerY, p[0] - centerX));
                
                let totalRotation = 0;
                for (let i = 1; i < angles.length; i++) {
                    let diff = angles[i] - angles[i-1];
                    while (diff > Math.PI) diff -= 2 * Math.PI;
                    while (diff < -Math.PI) diff += 2 * Math.PI;
                    totalRotation += Math.abs(diff);
                }
                
                rotationCount = totalRotation / (2 * Math.PI);
            }
            
            // 最大速度（跳过开头的边界伪影帧）
            const skipFrames = Math.max(5, Math.floor(speeds.length * 0.10));
            let maxSpeed = 0;
            for (let i = skipFrames; i < speeds.length; i++) {
                if (speeds[i] > maxSpeed) maxSpeed = speeds[i];
            }
            
            // 动作时间
            const totalTime = times[releaseIdx] - times[0];
            
            // 轨迹长度
            let trajectoryLength = 0;
            for (let j = 1; j < releaseIdx; j++) {
                const diff = positions[j].map((v, k) => v - positions[j-1][k]);
                trajectoryLength += Math.sqrt(diff.reduce((s, v) => s + v*v, 0));
            }
            
            // 预估距离：基于出手三要素（速度、角度、高度）的抛体运动公式
            // R = (v² * cosθ / g) * [sinθ + √(sin²θ + 2gh/v²)]
            const g = 9.81;
            const angleRad = releaseAngle * Math.PI / 180;
            const cosA = Math.cos(angleRad);
            const sinA = Math.sin(angleRad);
            const v = releaseVelocity;
            const h = releaseHeight;
            let estimatedDistance = 0;
            if (v > 0 && cosA > 0) {
                const discriminant = sinA * sinA + 2 * g * h / (v * v);
                if (discriminant >= 0) {
                    estimatedDistance = (v * v * cosA / g) * (sinA + Math.sqrt(discriminant));
                }
            }
            
            return {
                release_velocity: Math.round(releaseVelocity * 100) / 100,
                release_height: Math.round(releaseHeight * 100) / 100,
                release_angle: Math.round(releaseAngle * 10) / 10,
                max_speed: Math.round(maxSpeed * 100) / 100,
                total_time: Math.round(totalTime * 1000) / 1000,
                trajectory_length: Math.round(trajectoryLength * 100) / 100,
                release_position: releasePos.map(x => Math.round(x * 100) / 100),
                estimated_distance: Math.round(estimatedDistance * 100) / 100
            };
        }
        
        // 自动检测技术阶段
        function autoDetectPhases(rawData, discusDataLocal, skeletonDataLocal, releasePointLocal, times) {
            const phases = [];
            const speeds = discusDataLocal.speeds;
            const positions = discusDataLocal.positions;
            const releaseIdx = releasePointLocal.index;
            const releaseTime = releasePointLocal.time;
            const nData = rawData.length;
            const nDiscus = speeds.length;
            
            // 提取脚部高度数据
            const footRHeights = rawData.map(row => row[SKELETON_JOINTS_IDX['ankle_r'] + 2]);
            const footLHeights = rawData.map(row => row[SKELETON_JOINTS_IDX['ankle_l'] + 2]);
            
            const TAKEOFF_THRESHOLD = 0.15;
            
            const discusToDataIdx = (dIdx) => Math.floor(dIdx * nData / nDiscus);
            const dataToDiscusIdx = (dataIdx) => Math.floor(dataIdx * nDiscus / nData);
            const safeGetTime = (dataIdx) => times[Math.max(0, Math.min(dataIdx, nData - 1))];
            
            const releaseDataIdx = discusToDataIdx(releaseIdx);
            
            // 检测预摆最大位置
            const angles = positions.map(p => Math.atan2(p[1], p[0]) * 180 / Math.PI);
            const angleChanges = [];
            for (let i = 1; i < angles.length; i++) {
                let diff = angles[i] - angles[i-1];
                while (diff > 180) diff -= 360;
                while (diff < -180) diff += 360;
                angleChanges.push(diff);
            }
            
            const searchStartIdx = Math.floor(nDiscus * 0.45);
            const searchEndIdx = Math.floor(nDiscus * 0.75);
            let prepStartIdx = searchStartIdx;
            
            for (let i = searchStartIdx + 5; i < searchEndIdx - 5 && i < angleChanges.length - 5; i++) {
                const avgBefore = angleChanges.slice(i-5, i).reduce((a,b) => a+b, 0) / 5;
                const avgAfter = angleChanges.slice(i, i+5).reduce((a,b) => a+b, 0) / 5;
                if (avgBefore < -0.1 && avgAfter > 0.1) {
                    prepStartIdx = i;
                    break;
                }
            }
            
            // 检测脚部离地和落地事件
            let searchStart = discusToDataIdx(prepStartIdx);
            
            let rightFootOffIdx = null;
            for (let i = searchStart; i < releaseDataIdx; i++) {
                if (footRHeights[i] > TAKEOFF_THRESHOLD) {
                    rightFootOffIdx = i;
                    break;
                }
            }
            if (rightFootOffIdx === null) {
                rightFootOffIdx = searchStart + Math.floor((releaseDataIdx - searchStart) * 0.2);
            }
            
            let leftFootOffIdx = null;
            for (let i = rightFootOffIdx; i < releaseDataIdx; i++) {
                if (footLHeights[i] > TAKEOFF_THRESHOLD) {
                    leftFootOffIdx = i;
                    break;
                }
            }
            if (leftFootOffIdx === null) {
                leftFootOffIdx = rightFootOffIdx + Math.floor((releaseDataIdx - rightFootOffIdx) * 0.3);
            }
            
            let rightFootLandIdx = null;
            for (let i = leftFootOffIdx; i < releaseDataIdx; i++) {
                if (footRHeights[i] < TAKEOFF_THRESHOLD) {
                    rightFootLandIdx = i;
                    break;
                }
            }
            if (rightFootLandIdx === null) {
                rightFootLandIdx = leftFootOffIdx + Math.floor((releaseDataIdx - leftFootOffIdx) * 0.3);
            }
            
            let leftFootLandIdx = null;
            for (let i = rightFootLandIdx; i < releaseDataIdx; i++) {
                if (footLHeights[i] < TAKEOFF_THRESHOLD) {
                    leftFootLandIdx = i;
                    break;
                }
            }
            if (leftFootLandIdx === null) {
                leftFootLandIdx = rightFootLandIdx + Math.floor((releaseDataIdx - rightFootLandIdx) * 0.3);
            }
            
            // 确保时间顺序
            let prepStartDataIdx = discusToDataIdx(prepStartIdx);
            prepStartDataIdx = Math.max(0, Math.min(prepStartDataIdx, releaseDataIdx - 50));
            rightFootOffIdx = Math.max(prepStartDataIdx + 1, Math.min(rightFootOffIdx, releaseDataIdx - 40));
            leftFootOffIdx = Math.max(rightFootOffIdx + 1, Math.min(leftFootOffIdx, releaseDataIdx - 30));
            rightFootLandIdx = Math.max(leftFootOffIdx + 1, Math.min(rightFootLandIdx, releaseDataIdx - 20));
            leftFootLandIdx = Math.max(rightFootLandIdx + 1, Math.min(leftFootLandIdx, releaseDataIdx - 10));
            
            const prepStartTime = safeGetTime(prepStartDataIdx);
            const rightFootOffTime = safeGetTime(rightFootOffIdx);
            const leftFootOffTime = safeGetTime(leftFootOffIdx);
            const rightFootLandTime = safeGetTime(rightFootLandIdx);
            const leftFootLandTime = safeGetTime(leftFootLandIdx);
            
            const PHASE_COLORS = {
                'preparation': '#22c55e', 'entry': '#3b82f6', 'airborne': '#f97316',
                'transition': '#8b5cf6', 'delivery': '#ef4444'
            };
            
            phases.push({
                id: 'preparation', name: '预备阶段', name_en: 'Preparation',
                start_time: Math.round(prepStartTime * 1000) / 1000,
                end_time: Math.round(rightFootOffTime * 1000) / 1000,
                start_frame: prepStartIdx,
                end_frame: dataToDiscusIdx(rightFootOffIdx),
                color: PHASE_COLORS['preparation'],
                metrics: { duration: Math.round((rightFootOffTime - prepStartTime) * 1000) / 1000 }
            });
            
            phases.push({
                id: 'entry', name: '进入旋转', name_en: 'Entry',
                start_time: Math.round(rightFootOffTime * 1000) / 1000,
                end_time: Math.round(leftFootOffTime * 1000) / 1000,
                start_frame: dataToDiscusIdx(rightFootOffIdx),
                end_frame: dataToDiscusIdx(leftFootOffIdx),
                color: PHASE_COLORS['entry'],
                metrics: { duration: Math.round((leftFootOffTime - rightFootOffTime) * 1000) / 1000 }
            });
            
            phases.push({
                id: 'airborne', name: '腾空阶段', name_en: 'Airborne',
                start_time: Math.round(leftFootOffTime * 1000) / 1000,
                end_time: Math.round(rightFootLandTime * 1000) / 1000,
                start_frame: dataToDiscusIdx(leftFootOffIdx),
                end_frame: dataToDiscusIdx(rightFootLandIdx),
                color: PHASE_COLORS['airborne'],
                metrics: { duration: Math.round((rightFootLandTime - leftFootOffTime) * 1000) / 1000 }
            });
            
            phases.push({
                id: 'transition', name: '过渡阶段', name_en: 'Transition',
                start_time: Math.round(rightFootLandTime * 1000) / 1000,
                end_time: Math.round(leftFootLandTime * 1000) / 1000,
                start_frame: dataToDiscusIdx(rightFootLandIdx),
                end_frame: dataToDiscusIdx(leftFootLandIdx),
                color: PHASE_COLORS['transition'],
                metrics: { duration: Math.round((leftFootLandTime - rightFootLandTime) * 1000) / 1000 }
            });
            
            phases.push({
                id: 'delivery', name: '最后用力', name_en: 'Delivery',
                start_time: Math.round(leftFootLandTime * 1000) / 1000,
                end_time: Math.round(releaseTime * 1000) / 1000,
                start_frame: dataToDiscusIdx(leftFootLandIdx),
                end_frame: releaseIdx,
                color: PHASE_COLORS['delivery'],
                metrics: { duration: Math.round((releaseTime - leftFootLandTime) * 1000) / 1000 }
            });
            
            return phases;
        }
        
        // 降采样数据
        function downsampleData(dataDict, targetPoints = 600) {
            const n = dataDict.positions.length;
            if (n <= targetPoints) return dataDict;
            
            const step = Math.max(1, Math.floor(n / targetPoints));
            const result = {
                times: dataDict.times.filter((_, i) => i % step === 0),
                positions: dataDict.positions.filter((_, i) => i % step === 0),
                speeds: dataDict.speeds.filter((_, i) => i % step === 0)
            };
            
            if (dataDict.velocities) {
                result.velocities = dataDict.velocities.filter((_, i) => i % step === 0);
            }
            
            return result;
        }
        
        // 降采样骨架数据
        function downsampleSkeleton(skeletonDataLocal, targetPoints = 600) {
            const n = skeletonDataLocal.frames.length;
            if (n <= targetPoints) return skeletonDataLocal;
            
            const step = Math.max(1, Math.floor(n / targetPoints));
            return {
                frames: skeletonDataLocal.frames.filter((_, i) => i % step === 0),
                bones: skeletonDataLocal.bones,
                joint_names: skeletonDataLocal.joint_names
            };
        }
        
        // 处理导入的文件
        async function processImportedFile(fileContent, fileName) {
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            
            const updateProgress = (percent, text) => {
                progressBar.style.width = percent + '%';
                if (text) progressText.textContent = text;
            };
            
            try {
                updateProgress(2, '正在检测字段位置...');
                
                // 首先检测字段位置
                const lines = fileContent.split('\n');
                if (lines.length < 3) {
                    throw new Error('文件内容不足，无法解析');
                }
                const headerRow = lines[0].trim().split('\t');
                // 找到第一个有效数据行（跳过header、参数行和均匀行）
                let sampleDataRow = findValidSampleRow(lines);
                let detected = detectFieldPositions(headerRow, sampleDataRow);
                
                // 如果用户在预览中选择了特定的数据组，使用用户选择的关节索引
                if (currentPreviewResult && currentPreviewResult.dataGroups && currentPreviewResult.dataGroups.length > 1) {
                    const selectedGroup = currentPreviewResult.dataGroups[currentPreviewResult.selectedGroupIndex];
                    if (selectedGroup && selectedGroup.joints) {
                        console.log('使用用户选择的数据组:', currentPreviewResult.selectedGroupIndex + 1);
                        detected.skeletonJoints = selectedGroup.joints;
                    }
                }
                
                if (!detected.success) {
                    throw new Error('关键字段未找到: ' + detected.missing.filter(f => f.includes('HAND_R')).join(', '));
                }
                
                // 应用检测到的字段位置
                applyDetectedPositions(detected);
                console.log('字段检测结果:', detected.found.slice(0, 5).join(', ') + '...');
                
                updateProgress(5, '正在解析数据文件...');
                const rawData = parseMotionCaptureFile(fileContent, updateProgress);
                
                if (rawData.length === 0) {
                    throw new Error('没有有效数据！请检查文件格式。');
                }
                
                console.log('有效数据行数:', rawData.length);
                
                updateProgress(35, '正在提取铁饼轨迹...');
                const discusDataLocal = extractDiscusTrajectory(rawData, updateProgress);
                
                updateProgress(50, '正在提取重心轨迹...');
                const comDataLocal = extractComTrajectory(rawData, updateProgress);
                
                updateProgress(60, '正在提取骨架数据...');
                const skeletonDataLocal = extractSkeletonData(rawData, updateProgress);
                
                updateProgress(75, '正在提取关节速度...');
                const jointSpeedsLocal = extractJointSpeeds(rawData);
                
                updateProgress(80, '正在分析释放点...');
                const releasePointLocal = findReleasePoint(discusDataLocal, skeletonDataLocal);
                
                updateProgress(85, '正在计算生物力学指标...');
                const biomechanicsLocal = calculateBiomechanics(discusDataLocal, comDataLocal, releasePointLocal);
                
                updateProgress(90, '正在检测技术阶段...');
                const times = rawData.map(row => row[COL_TIME]);
                const autoPhasesLocal = autoDetectPhases(rawData, discusDataLocal, skeletonDataLocal, releasePointLocal, times);
                
                updateProgress(95, '正在降采样数据...');
                const discusDataSampled = downsampleData(discusDataLocal, 600);
                const comDataSampled = downsampleData(comDataLocal, 600);
                const skeletonDataSampled = downsampleSkeleton(skeletonDataLocal, 600);
                
                // 降采样关节速度
                const n = rawData.length;
                const step = Math.max(1, Math.floor(n / 600));
                const jointSpeedsSampled = {};
                for (const [jointName, jointData] of Object.entries(jointSpeedsLocal)) {
                    jointSpeedsSampled[jointName] = {
                        speeds: jointData.speeds.filter((_, i) => i % step === 0),
                        name_cn: jointData.name_cn,
                        max_speed: jointData.max_speed,
                        avg_speed: jointData.avg_speed
                    };
                }
                
                updateProgress(100, '处理完成！');
                
                // 提取运动员名称（从文件名）
                const athleteName = fileName.replace('.txt', '').replace('all', '').replace(/_/g, ' ').trim() || '未知运动员';
                
                return {
                    athlete: athleteName,
                    event: '女子铁饼',
                    discus: discusDataSampled,
                    com: comDataSampled,
                    skeleton: skeletonDataSampled,
                    rotation: null,
                    joint_speeds: jointSpeedsSampled,
                    release_point: releasePointLocal,
                    biomechanics: biomechanicsLocal,
                    auto_phases: autoPhasesLocal
                };
                
            } catch (error) {
                console.error('处理文件失败:', error);
                throw error;
            }
        }
        
        // 打开导入弹窗
        function openImportModal() {
            document.getElementById('import-modal').classList.add('show');
            selectedFile = null;
            currentPreviewResult = null;
            document.getElementById('import-file-selected').classList.remove('show');
            document.getElementById('import-drop-zone').style.display = 'block';
            document.getElementById('import-progress').classList.remove('show');
            document.getElementById('import-preview').classList.remove('show');
            document.getElementById('import-confirm-btn').disabled = true;
            document.getElementById('progress-bar').style.width = '0%';
            // 重置数据组选择器和骨架预览区域
            document.getElementById('data-group-selector').style.display = 'none';
            document.getElementById('skeleton-preview-section').style.display = 'none';
            // 重置文件输入框，确保选择相同文件时也会触发 change 事件
            document.getElementById('file-input').value = '';
        }
        
        // 关闭导入弹窗
        function closeImportModal() {
            document.getElementById('import-modal').classList.remove('show');
            selectedFile = null;
        }
        
        // 处理文件选择
        async function handleFileSelect(file) {
            if (!file || !file.name.endsWith('.txt')) {
                alert('请选择 .txt 格式的动捕数据文件');
                return;
            }
            
            selectedFile = file;
            document.getElementById('import-drop-zone').style.display = 'none';
            document.getElementById('import-file-selected').classList.add('show');
            document.getElementById('selected-file-name').textContent = file.name;
            document.getElementById('selected-file-size').textContent = formatFileSize(file.size);
            
            // 显示预览区域并开始解析
            document.getElementById('import-preview').classList.add('show');
            document.getElementById('import-confirm-btn').disabled = true;
            
            // 重置预览状态
            document.getElementById('preview-status').className = 'preview-status';
            document.getElementById('preview-status-icon').textContent = '⏳';
            document.getElementById('preview-status-text').textContent = '正在分析数据...';
            
            try {
                const content = await file.text();
                const previewResult = generateDataPreview(content);
                displayDataPreview(previewResult);
            } catch (error) {
                console.error('预览生成失败:', error);
                document.getElementById('preview-status').className = 'preview-status invalid';
                document.getElementById('preview-status-icon').textContent = '❌';
                document.getElementById('preview-status-text').textContent = '文件读取失败: ' + error.message;
            }
        }
        
        // 骨架数据验证函数 - 检查骨架数据是否符合人体比例
        function validateSkeletonData(sampleRow, jointIndices) {
            const metrics = {
                height: null,           // 身高（头到脚）
                shoulderWidth: null,    // 肩宽
                armLength: null,        // 臂长
                legLength: null,        // 腿长
                isValid: true,
                score: 100,             // 数据质量评分 0-100
                issues: [],
                warnings: []
            };
            
            if (!sampleRow || !jointIndices) {
                metrics.isValid = false;
                metrics.score = 0;
                metrics.issues.push('无法获取骨架数据');
                return metrics;
            }
            
            // 辅助函数：获取关节的 XYZ 坐标
            function getJointPos(jointName) {
                const xIdx = jointIndices[jointName];
                if (xIdx === undefined || xIdx === -1) return null;
                const x = parseFloat(sampleRow[xIdx]);
                const y = parseFloat(sampleRow[xIdx + 1]);
                const z = parseFloat(sampleRow[xIdx + 2]);
                if (isNaN(x) || isNaN(y) || isNaN(z)) return null;
                return { x, y, z };
            }
            
            // 辅助函数：计算两点之间的距离
            function distance(p1, p2) {
                if (!p1 || !p2) return null;
                return Math.sqrt(
                    Math.pow(p1.x - p2.x, 2) + 
                    Math.pow(p1.y - p2.y, 2) + 
                    Math.pow(p1.z - p2.z, 2)
                );
            }
            
            // 获取关键关节位置
            const head = getJointPos('head');
            const neck = getJointPos('neck');
            const shoulderR = getJointPos('shoulder_r');
            const shoulderL = getJointPos('shoulder_l');
            const elbowR = getJointPos('elbow_r');
            const elbowL = getJointPos('elbow_l');
            const wristR = getJointPos('wrist_r');
            const wristL = getJointPos('wrist_l');
            const hipR = getJointPos('hip_r');
            const hipL = getJointPos('hip_l');
            const kneeR = getJointPos('knee_r');
            const kneeL = getJointPos('knee_l');
            const ankleR = getJointPos('ankle_r');
            const ankleL = getJointPos('ankle_l');
            const footR = getJointPos('foot_r');
            const footL = getJointPos('foot_l');
            
            // 1. 计算身高（头部Z坐标 - 脚部Z坐标，或头到脚的垂直距离）
            if (head && (footR || footL || ankleR || ankleL)) {
                const footZ = footR ? footR.z : (footL ? footL.z : (ankleR ? ankleR.z : ankleL.z));
                metrics.height = Math.abs(head.z - footZ);
                
                // 验证身高是否在合理范围 (1.4m - 2.2m)
                if (metrics.height < 1.4) {
                    metrics.warnings.push(`身高偏低: ${metrics.height.toFixed(2)}m`);
                    metrics.score -= 15;
                } else if (metrics.height > 2.2) {
                    metrics.issues.push(`身高异常: ${metrics.height.toFixed(2)}m (超出正常范围)`);
                    metrics.score -= 30;
                    metrics.isValid = false;
                }
            }
            
            // 2. 计算肩宽
            if (shoulderR && shoulderL) {
                metrics.shoulderWidth = distance(shoulderR, shoulderL);
                
                // 验证肩宽是否在合理范围 (0.25m - 0.6m)
                if (metrics.shoulderWidth < 0.25) {
                    metrics.warnings.push(`肩宽偏窄: ${metrics.shoulderWidth.toFixed(2)}m`);
                    metrics.score -= 10;
                } else if (metrics.shoulderWidth > 0.6) {
                    metrics.issues.push(`肩宽异常: ${metrics.shoulderWidth.toFixed(2)}m`);
                    metrics.score -= 20;
                }
            }
            
            // 3. 计算臂长（肩到腕）
            const armLengthR = distance(shoulderR, elbowR) !== null && distance(elbowR, wristR) !== null
                ? distance(shoulderR, elbowR) + distance(elbowR, wristR) : null;
            const armLengthL = distance(shoulderL, elbowL) !== null && distance(elbowL, wristL) !== null
                ? distance(shoulderL, elbowL) + distance(elbowL, wristL) : null;
            
            if (armLengthR !== null || armLengthL !== null) {
                metrics.armLength = armLengthR || armLengthL;
                
                // 验证臂长是否在合理范围 (0.4m - 0.9m)
                if (metrics.armLength < 0.4) {
                    metrics.warnings.push(`臂长偏短: ${metrics.armLength.toFixed(2)}m`);
                    metrics.score -= 10;
                } else if (metrics.armLength > 0.9) {
                    metrics.issues.push(`臂长异常: ${metrics.armLength.toFixed(2)}m`);
                    metrics.score -= 20;
                }
            }
            
            // 4. 计算腿长（髋到踝）
            const legLengthR = distance(hipR, kneeR) !== null && distance(kneeR, ankleR) !== null
                ? distance(hipR, kneeR) + distance(kneeR, ankleR) : null;
            const legLengthL = distance(hipL, kneeL) !== null && distance(kneeL, ankleL) !== null
                ? distance(hipL, kneeL) + distance(kneeL, ankleL) : null;
            
            if (legLengthR !== null || legLengthL !== null) {
                metrics.legLength = legLengthR || legLengthL;
                
                // 验证腿长是否在合理范围 (0.6m - 1.2m)
                if (metrics.legLength < 0.6) {
                    metrics.warnings.push(`腿长偏短: ${metrics.legLength.toFixed(2)}m`);
                    metrics.score -= 10;
                } else if (metrics.legLength > 1.2) {
                    metrics.issues.push(`腿长异常: ${metrics.legLength.toFixed(2)}m`);
                    metrics.score -= 20;
                }
            }
            
            // 5. 检查关节Z坐标是否都在合理范围 (0 - 2.5m)
            const allJoints = [head, neck, shoulderR, shoulderL, elbowR, elbowL, wristR, wristL,
                              hipR, hipL, kneeR, kneeL, ankleR, ankleL, footR, footL];
            let abnormalZCount = 0;
            for (const joint of allJoints) {
                if (joint && (joint.z < -0.5 || joint.z > 3.0)) {
                    abnormalZCount++;
                }
            }
            if (abnormalZCount > 3) {
                metrics.issues.push(`${abnormalZCount}个关节Z坐标异常，可能选择了错误的数据组`);
                metrics.score -= 40;
                metrics.isValid = false;
            }
            
            // 确保分数不低于0
            metrics.score = Math.max(0, metrics.score);
            
            // 根据分数判断整体有效性
            if (metrics.score < 50) {
                metrics.isValid = false;
            }
            
            return metrics;
        }
        
        // 检测所有数据组并返回每组的验证结果
        function detectAllDataGroups(headerRow, sampleDataRow) {
            const groups = [];
            
            // 以 hip_r 作为参考字段来检测数据组
            const hipPattern = '/Joint/Hip/Right X';
            const matches = [];
            for (let i = 0; i < headerRow.length; i++) {
                if (headerRow[i].includes(hipPattern)) {
                    matches.push(i);
                }
            }
            
            if (matches.length <= 1) {
                // 只有一组数据
                return null;
            }
            
            // 对每组数据进行验证
            // 改进：对于每个关节模式，找到所有匹配位置，然后选择最接近当前组 hip 位置的那个
            for (let groupIdx = 0; groupIdx < matches.length; groupIdx++) {
                const baseIdx = matches[groupIdx]; // 当前组的 hip_r 位置
                
                // 计算当前组的预期范围
                // 下一组的 hip 位置（如果有的话）
                const nextGroupHip = groupIdx < matches.length - 1 ? matches[groupIdx + 1] : headerRow.length;
                // 上一组的 hip 位置（如果有的话）
                const prevGroupHip = groupIdx > 0 ? matches[groupIdx - 1] : 0;
                
                // 在当前组的范围内查找所有关节
                const estimatedJoints = {};
                
                for (const [jointName, patterns] of Object.entries(SKELETON_FIELD_PATTERNS)) {
                    // 找到所有匹配的位置
                    const allMatches = [];
                    for (const pattern of patterns) {
                        for (let i = 0; i < headerRow.length; i++) {
                            if (headerRow[i].includes(pattern) || headerRow[i] === pattern) {
                                allMatches.push(i);
                            }
                        }
                    }
                    
                    if (allMatches.length > 0) {
                        // 选择最接近当前组 hip 位置的匹配
                        // 但要在合理范围内：大于等于 prevGroupHip 且小于 nextGroupHip
                        let bestMatch = null;
                        let bestDistance = Infinity;
                        
                        for (const matchIdx of allMatches) {
                            // 计算该匹配与当前组 hip 的距离
                            const distance = Math.abs(matchIdx - baseIdx);
                            
                            // 判断该匹配是否属于当前组
                            // 使用中点作为边界：如果匹配位置更接近当前组的 hip，则属于当前组
                            const distToCurrentHip = Math.abs(matchIdx - baseIdx);
                            const distToNextHip = groupIdx < matches.length - 1 ? Math.abs(matchIdx - matches[groupIdx + 1]) : Infinity;
                            const distToPrevHip = groupIdx > 0 ? Math.abs(matchIdx - matches[groupIdx - 1]) : Infinity;
                            
                            // 只有当该匹配最接近当前组的 hip 时才选择它
                            if (distToCurrentHip <= distToNextHip && distToCurrentHip <= distToPrevHip) {
                                if (distance < bestDistance) {
                                    bestDistance = distance;
                                    bestMatch = matchIdx;
                                }
                            }
                        }
                        
                        if (bestMatch !== null) {
                            estimatedJoints[jointName] = bestMatch;
                        }
                    }
                }
                
                // 验证这组数据
                const validation = validateSkeletonData(sampleDataRow, estimatedJoints);
                
                groups.push({
                    index: groupIdx,
                    startCol: baseIdx,
                    searchRange: `基于hip位置(${baseIdx})智能匹配`,
                    joints: estimatedJoints,
                    validation: validation,
                    recommended: false
                });
            }
            
            // 找出推荐的数据组（分数最高的）
            if (groups.length > 0) {
                let bestGroup = groups[0];
                for (const group of groups) {
                    if (group.validation.score > bestGroup.validation.score) {
                        bestGroup = group;
                    }
                }
                bestGroup.recommended = true;
            }
            
            return groups;
        }
        
        // 绘制骨架预览图
        function drawSkeletonPreview(sampleRow, jointIndices, validation) {
            const canvas = document.getElementById('skeleton-preview-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // 清空画布
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, width, height);
            
            if (!sampleRow || !jointIndices) {
                ctx.fillStyle = '#9ca3af';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('无数据', width / 2, height / 2);
                return;
            }
            
            // 辅助函数：获取关节位置
            function getJointPos(jointName) {
                const xIdx = jointIndices[jointName];
                if (xIdx === undefined || xIdx === -1) return null;
                const x = parseFloat(sampleRow[xIdx]);
                const y = parseFloat(sampleRow[xIdx + 1]);
                const z = parseFloat(sampleRow[xIdx + 2]);
                if (isNaN(x) || isNaN(y) || isNaN(z)) return null;
                return { x, y, z };
            }
            
            // 获取所有关节位置
            const joints = {};
            const jointNames = ['head', 'neck', 'shoulder_r', 'shoulder_l', 'elbow_r', 'elbow_l',
                              'wrist_r', 'wrist_l', 'hip_r', 'hip_l', 'knee_r', 'knee_l',
                              'ankle_r', 'ankle_l', 'pelvis', 'torso'];
            
            let minX = Infinity, maxX = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            
            for (const name of jointNames) {
                const pos = getJointPos(name);
                if (pos) {
                    joints[name] = pos;
                    minX = Math.min(minX, pos.x);
                    maxX = Math.max(maxX, pos.x);
                    minZ = Math.min(minZ, pos.z);
                    maxZ = Math.max(maxZ, pos.z);
                }
            }
            
            // 如果没有足够的关节数据，显示提示
            if (Object.keys(joints).length < 5) {
                ctx.fillStyle = '#9ca3af';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('关节数据不足', width / 2, height / 2);
                return;
            }
            
            // 计算缩放和偏移（正面视图：X-Z平面）
            const padding = 20;
            const rangeX = maxX - minX || 1;
            const rangeZ = maxZ - minZ || 1;
            const scale = Math.min((width - 2 * padding) / rangeX, (height - 2 * padding) / rangeZ) * 0.8;
            const centerX = (minX + maxX) / 2;
            const centerZ = (minZ + maxZ) / 2;
            
            // 坐标转换函数（正面视图）
            function toCanvas(pos) {
                if (!pos) return null;
                return {
                    x: width / 2 + (pos.x - centerX) * scale,
                    y: height - padding - (pos.z - minZ) * scale
                };
            }
            
            // 定义骨架连接
            const connections = [
                ['head', 'neck'],
                ['neck', 'shoulder_r'], ['neck', 'shoulder_l'],
                ['shoulder_r', 'elbow_r'], ['shoulder_l', 'elbow_l'],
                ['elbow_r', 'wrist_r'], ['elbow_l', 'wrist_l'],
                ['neck', 'torso'], ['torso', 'pelvis'],
                ['pelvis', 'hip_r'], ['pelvis', 'hip_l'],
                ['hip_r', 'knee_r'], ['hip_l', 'knee_l'],
                ['knee_r', 'ankle_r'], ['knee_l', 'ankle_l']
            ];
            
            // 绘制骨架连接线
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            
            for (const [from, to] of connections) {
                const p1 = toCanvas(joints[from]);
                const p2 = toCanvas(joints[to]);
                if (p1 && p2) {
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            }
            
            // 绘制关节点
            for (const [name, pos] of Object.entries(joints)) {
                const p = toCanvas(pos);
                if (p) {
                    // 判断关节是否异常
                    const isAbnormal = pos.z < -0.5 || pos.z > 3.0;
                    
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = isAbnormal ? '#ef4444' : '#22c55e';
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
            
            // 绘制标题
            ctx.fillStyle = '#6b7280';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('正面视图 (X-Z)', width / 2, height - 5);
        }
        
        // 生成数据预览
        function generateDataPreview(content) {
            const lines = content.split('\n');
            const result = {
                totalLines: 0,
                dataLines: 0,
                totalCols: 0,
                headerRow: [],
                timeValues: [],
                cogValues: [],
                handValues: [],
                isValid: false,
                hasTimeColumn: false,
                hasCogColumn: false,
                hasHandColumn: false,
                issues: [],
                warnings: [],
                // 字段检测结果
                detected: null,
                detectedPositions: {
                    cog: -1,
                    hand: -1,
                    skeletonCount: 0
                }
            };
            
            // 解析标题行
            if (lines.length > 0) {
                const headerLine = lines[0].trim();
                result.headerRow = headerLine.split('\t');
                result.totalCols = result.headerRow.length;
                
                // 找到第一个有效数据行用于智能检测（跳过均匀行）
                let sampleDataRow = findValidSampleRow(lines);
                
                // 使用自动检测函数检测字段位置（传入样本数据行用于智能选择）
                result.detected = detectFieldPositions(result.headerRow, sampleDataRow);
                
                // 记录检测到的位置
                result.detectedPositions.cog = result.detected.fields['COG_X'];
                result.detectedPositions.hand = result.detected.fields['HAND_R_X'];
                result.detectedPositions.skeletonCount = Object.values(result.detected.skeletonJoints).filter(v => v !== -1).length;
            }
            
            // 检查关键字段是否存在
            if (result.detected) {
                if (result.detected.fields['HAND_R_X'] === -1) {
                    result.issues.push('未找到右手位置字段 (Hand/Index/Base/Right)，铁饼轨迹无法显示');
                }
                if (result.detected.fields['COG_X'] === -1) {
                    result.warnings.push('未找到重心位置字段 (CenterOfGravity)，重心轨迹将不可用');
                }
                if (result.detectedPositions.skeletonCount < 10) {
                    result.warnings.push(`仅检测到 ${result.detectedPositions.skeletonCount} 个骨架关节点，骨架显示可能不完整`);
                }
            }
            
            // 使用检测到的位置读取数据样本
            const previewCogX = result.detected ? result.detected.fields['COG_X'] : -1;
            const previewCogY = result.detected ? result.detected.fields['COG_Y'] : -1;
            const previewCogZ = result.detected ? result.detected.fields['COG_Z'] : -1;
            const previewHandX = result.detected ? result.detected.fields['HAND_R_X'] : -1;
            const previewHandY = result.detected ? result.detected.fields['HAND_R_Y'] : -1;
            const previewHandZ = result.detected ? result.detected.fields['HAND_R_Z'] : -1;
            
            // 解析数据行（跳过前两行：标题和参数行，以及均匀行）
            let validDataRows = 0;
            const sampleSize = 5;
            
            for (let i = 2; i < lines.length && validDataRows < sampleSize; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const parts = line.split('\t');
                if (parts.length > 100) {
                    try {
                        const values = parts.map(x => x ? parseFloat(x) : 0.0);
                        const time = values[0]; // 时间始终在第0列
                        
                        // 只取有效数据（时间 > 0），并跳过均匀行
                        if (time > 0 && !isUniformRow(values)) {
                            result.timeValues.push(time.toFixed(4));
                            
                            // 使用检测到的位置读取重心数据
                            if (previewCogX !== -1) {
                                const cogX = values[previewCogX] || 0;
                                const cogY = values[previewCogY] || 0;
                                const cogZ = values[previewCogZ] || 0;
                                result.cogValues.push(`[${cogX.toFixed(2)}, ${cogY.toFixed(2)}, ${cogZ.toFixed(2)}]`);
                            } else {
                                result.cogValues.push('[未检测到]');
                            }
                            
                            // 使用检测到的位置读取右手数据
                            if (previewHandX !== -1) {
                                const handX = values[previewHandX] || 0;
                                const handY = values[previewHandY] || 0;
                                const handZ = values[previewHandZ] || 0;
                                result.handValues.push(`[${handX.toFixed(2)}, ${handY.toFixed(2)}, ${handZ.toFixed(2)}]`);
                            } else {
                                result.handValues.push('[未检测到]');
                            }
                            
                            validDataRows++;
                        }
                    } catch (e) {
                        continue;
                    }
                }
            }
            
            // 统计总数据行数（排除均匀行）
            result.totalLines = lines.length;
            for (let i = 2; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                const parts = line.split('\t');
                if (parts.length > 100) {
                    try {
                        const values = parts.map(x => x ? parseFloat(x) : 0.0);
                        if (values[0] > 0 && !isUniformRow(values)) {
                            result.dataLines++;
                        }
                    } catch (e) {
                        continue;
                    }
                }
            }
            
            // 验证数据质量
            result.hasTimeColumn = result.timeValues.length > 0;
            result.hasCogColumn = result.cogValues.some(v => !v.includes('[0.00, 0.00, 0.00]') && !v.includes('[未检测到]'));
            result.hasHandColumn = result.handValues.some(v => !v.includes('[0.00, 0.00, 0.00]') && !v.includes('[未检测到]'));
            
            // 检查数据是否异常（全部为零或时间戳异常）
            if (!result.hasTimeColumn) {
                result.issues.push('未检测到有效的时间戳数据');
            }
            
            // 只有在检测到 COG 字段但数据为零时才报告问题
            if (result.detectedPositions.cog !== -1 && !result.hasCogColumn) {
                result.warnings.push('重心位置数据全部为零，可能数据异常');
            }
            
            // 只有在检测到 Hand 字段但数据为零时才报告问题
            if (result.detectedPositions.hand !== -1 && !result.hasHandColumn) {
                result.issues.push('右手位置数据全部为零，铁饼轨迹将无法显示');
            }
            
            // 检查数据行数
            if (result.dataLines < 100) {
                result.warnings.push(`有效数据行数较少 (${result.dataLines} 行)，分析结果可能不完整`);
            }
            
            // 检查时间戳是否递增
            if (result.timeValues.length >= 2) {
                const times = result.timeValues.map(parseFloat);
                let isIncreasing = true;
                for (let i = 1; i < times.length; i++) {
                    if (times[i] <= times[i-1]) {
                        isIncreasing = false;
                        break;
                    }
                }
                if (!isIncreasing) {
                    result.warnings.push('时间戳不是严格递增的，数据可能存在问题');
                }
            }
            
            // 综合判断：只要检测到右手字段且有有效数据，就可以导入
            const hasHandField = result.detectedPositions.hand !== -1;
            result.isValid = result.issues.length === 0 && result.hasTimeColumn && hasHandField;
            
            // 检测多组数据并进行骨架验证（跳过均匀行）
            let sampleDataRow = findValidSampleRow(lines);
            
            // 检测所有数据组
            result.dataGroups = detectAllDataGroups(result.headerRow, sampleDataRow);
            result.selectedGroupIndex = 0;
            
            // 如果有多组数据，默认选择推荐的那组
            if (result.dataGroups && result.dataGroups.length > 1) {
                for (let i = 0; i < result.dataGroups.length; i++) {
                    if (result.dataGroups[i].recommended) {
                        result.selectedGroupIndex = i;
                        break;
                    }
                }
            }
            
            // 进行骨架验证
            if (result.detected && result.detected.skeletonJoints) {
                result.skeletonValidation = validateSkeletonData(sampleDataRow, result.detected.skeletonJoints);
                
                // 将骨架验证的问题和警告添加到总结果中
                if (result.skeletonValidation.issues.length > 0) {
                    result.warnings.push(...result.skeletonValidation.issues);
                }
                if (result.skeletonValidation.warnings.length > 0) {
                    result.warnings.push(...result.skeletonValidation.warnings);
                }
            }
            
            // 保存样本数据行供绘制预览图使用
            result.sampleDataRow = sampleDataRow;
            
            return result;
        }
        
        // 显示数据预览
        function displayDataPreview(result) {
            // 保存到全局变量，供数据组选择使用
            currentPreviewResult = result;
            
            // 统计信息
            document.getElementById('preview-stats').textContent = 
                `${result.totalLines} 行 / ${result.dataLines} 有效数据行`;
            
            // 时间值
            const timeEl = document.getElementById('preview-time');
            if (result.timeValues.length > 0) {
                timeEl.textContent = result.timeValues.join(' → ');
                timeEl.className = 'preview-field-values success';
            } else {
                timeEl.textContent = '无有效数据';
                timeEl.className = 'preview-field-values error';
            }
            
            // 重心位置
            const cogEl = document.getElementById('preview-cog');
            if (result.cogValues.length > 0) {
                cogEl.textContent = result.cogValues.join(' → ');
                cogEl.className = result.hasCogColumn ? 'preview-field-values success' : 'preview-field-values warning';
            } else {
                cogEl.textContent = '无有效数据';
                cogEl.className = 'preview-field-values error';
            }
            
            // 右手位置
            const handEl = document.getElementById('preview-hand');
            if (result.handValues.length > 0) {
                handEl.textContent = result.handValues.join(' → ');
                handEl.className = result.hasHandColumn ? 'preview-field-values success' : 'preview-field-values error';
            } else {
                handEl.textContent = '无有效数据';
                handEl.className = 'preview-field-values error';
            }
            
            // 列数
            const colsEl = document.getElementById('preview-cols');
            colsEl.textContent = `${result.totalCols} 列`;
            colsEl.className = result.totalCols >= 100 ? 'preview-field-values success' : 'preview-field-values error';
            
            // 重心字段位置（使用自动检测结果）
            const cogPosEl = document.getElementById('preview-cog-pos');
            const cogPos = result.detectedPositions.cog;
            if (cogPos !== -1) {
                cogPosEl.textContent = `✓ 自动检测到: 列${cogPos}`;
                cogPosEl.className = 'preview-field-values success';
            } else {
                cogPosEl.textContent = '未检测到 (可选字段)';
                cogPosEl.className = 'preview-field-values warning';
            }
            
            // 右手字段位置（使用自动检测结果）
            const handPosEl = document.getElementById('preview-hand-pos');
            const handPos = result.detectedPositions.hand;
            if (handPos !== -1) {
                handPosEl.textContent = `✓ 自动检测到: 列${handPos}`;
                handPosEl.className = 'preview-field-values success';
            } else {
                handPosEl.textContent = '❌ 未检测到 (必需字段)';
                handPosEl.className = 'preview-field-values error';
            }
            
            // 骨架关节点检测结果 - 显示所有27个关节
            const skeletonListEl = document.getElementById('preview-skeleton-list');
            const jointNamesCn = {
                'root': '根节点', 'pelvis': '骨盆', 'spine_low': '下脊柱', 'spine_high': '上脊柱',
                'torso': '躯干', 'neck': '颈部', 'head': '头部',
                'clavicle_r': '右锁骨', 'shoulder_r': '右肩', 'elbow_r': '右肘', 'wrist_r': '右腕',
                'hand_index_r': '右手食指', 'hand_little_r': '右手小指',
                'clavicle_l': '左锁骨', 'shoulder_l': '左肩', 'elbow_l': '左肘', 'wrist_l': '左腕',
                'hand_index_l': '左手食指', 'hand_little_l': '左手小指',
                'hip_r': '右髋', 'knee_r': '右膝', 'ankle_r': '右踝', 'foot_r': '右脚',
                'hip_l': '左髋', 'knee_l': '左膝', 'ankle_l': '左踝', 'foot_l': '左脚',
            };
            
            // 按顺序排列关节点
            const jointOrder = [
                'head', 'neck', 'torso', 'spine_high', 'spine_low', 'pelvis', 'root',
                'clavicle_r', 'shoulder_r', 'elbow_r', 'wrist_r', 'hand_index_r', 'hand_little_r',
                'clavicle_l', 'shoulder_l', 'elbow_l', 'wrist_l', 'hand_index_l', 'hand_little_l',
                'hip_r', 'knee_r', 'ankle_r', 'foot_r',
                'hip_l', 'knee_l', 'ankle_l', 'foot_l'
            ];
            
            let skeletonHtml = '';
            let foundCount = 0;
            
            if (result.detected && result.detected.skeletonJoints) {
                for (const jointKey of jointOrder) {
                    const colIdx = result.detected.skeletonJoints[jointKey];
                    const cnName = jointNamesCn[jointKey] || jointKey;
                    const isFound = colIdx !== undefined && colIdx !== -1;
                    
                    if (isFound) foundCount++;
                    
                    skeletonHtml += `
                        <div class="skeleton-joint-item ${isFound ? 'found' : 'missing'}">
                            <span class="joint-icon">${isFound ? '✓' : '✗'}</span>
                            <span class="joint-name">${cnName}</span>
                            ${isFound ? `<span class="joint-col">列${colIdx}</span>` : ''}
                        </div>
                    `;
                }
            }
            
            skeletonListEl.innerHTML = skeletonHtml || '<div style="color:#666;text-align:center;grid-column:1/-1;">未检测到关节数据</div>';
            
            // 更新检测数量到 result 中
            result.detectedPositions.skeletonCount = foundCount;
            
            // 显示数据组选择器（如果检测到多组数据）
            const groupSelectorEl = document.getElementById('data-group-selector');
            const groupOptionsEl = document.getElementById('data-group-options');
            
            if (result.dataGroups && result.dataGroups.length > 1) {
                groupSelectorEl.style.display = 'block';
                
                let groupsHtml = '';
                for (let i = 0; i < result.dataGroups.length; i++) {
                    const group = result.dataGroups[i];
                    const validation = group.validation;
                    const isSelected = i === result.selectedGroupIndex;
                    const badgeClass = validation.score >= 80 ? 'recommended' : 
                                      (validation.score >= 50 ? 'warning' : 'error');
                    const badgeText = group.recommended ? '推荐' : 
                                     (validation.score >= 80 ? '正常' : 
                                      (validation.score >= 50 ? '警告' : '异常'));
                    
                    groupsHtml += `
                        <div class="data-group-option ${isSelected ? 'selected' : ''} ${group.recommended ? 'recommended' : ''}" 
                             data-group-index="${i}" onclick="selectDataGroup(${i}, this)">
                            <input type="radio" name="dataGroup" value="${i}" ${isSelected ? 'checked' : ''}>
                            <div class="group-info">
                                <div class="group-name">数据组 ${i + 1} (列${group.startCol}起)</div>
                                <div class="group-details">
                                    身高: ${validation.height ? validation.height.toFixed(2) + 'm' : '--'} | 
                                    评分: ${validation.score}分
                                </div>
                            </div>
                            <span class="group-badge ${badgeClass}">${badgeText}</span>
                        </div>
                    `;
                }
                groupOptionsEl.innerHTML = groupsHtml;
            } else {
                groupSelectorEl.style.display = 'none';
            }
            
            // 显示骨架预览和验证结果
            const previewSectionEl = document.getElementById('skeleton-preview-section');
            if (result.skeletonValidation) {
                previewSectionEl.style.display = 'block';
                const validation = result.skeletonValidation;
                
                // 绘制骨架预览图
                if (result.detected && result.detected.skeletonJoints && result.sampleDataRow) {
                    drawSkeletonPreview(result.sampleDataRow, result.detected.skeletonJoints, validation);
                }
                
                // 显示骨架指标
                const heightEl = document.getElementById('metric-height');
                const shoulderEl = document.getElementById('metric-shoulder');
                const armEl = document.getElementById('metric-arm');
                const legEl = document.getElementById('metric-leg');
                
                if (validation.height !== null) {
                    heightEl.textContent = validation.height.toFixed(2) + 'm';
                    heightEl.className = 'metric-value ' + 
                        (validation.height >= 1.4 && validation.height <= 2.2 ? 'normal' : 
                         (validation.height >= 1.2 && validation.height <= 2.5 ? 'warning' : 'error'));
                } else {
                    heightEl.textContent = '--';
                    heightEl.className = 'metric-value';
                }
                
                if (validation.shoulderWidth !== null) {
                    shoulderEl.textContent = validation.shoulderWidth.toFixed(2) + 'm';
                    shoulderEl.className = 'metric-value ' + 
                        (validation.shoulderWidth >= 0.25 && validation.shoulderWidth <= 0.6 ? 'normal' : 'warning');
                } else {
                    shoulderEl.textContent = '--';
                    shoulderEl.className = 'metric-value';
                }
                
                if (validation.armLength !== null) {
                    armEl.textContent = validation.armLength.toFixed(2) + 'm';
                    armEl.className = 'metric-value ' + 
                        (validation.armLength >= 0.4 && validation.armLength <= 0.9 ? 'normal' : 'warning');
                } else {
                    armEl.textContent = '--';
                    armEl.className = 'metric-value';
                }
                
                if (validation.legLength !== null) {
                    legEl.textContent = validation.legLength.toFixed(2) + 'm';
                    legEl.className = 'metric-value ' + 
                        (validation.legLength >= 0.6 && validation.legLength <= 1.2 ? 'normal' : 'warning');
                } else {
                    legEl.textContent = '--';
                    legEl.className = 'metric-value';
                }
                
                // 显示数据质量评分
                const scoreValueEl = document.getElementById('score-value');
                const scoreFillEl = document.getElementById('score-fill');
                const score = validation.score;
                
                let scoreClass = 'error';
                let scoreText = '异常';
                if (score >= 80) {
                    scoreClass = 'excellent';
                    scoreText = '优秀';
                } else if (score >= 60) {
                    scoreClass = 'good';
                    scoreText = '良好';
                } else if (score >= 40) {
                    scoreClass = 'warning';
                    scoreText = '警告';
                }
                
                scoreValueEl.textContent = `${score}分 (${scoreText})`;
                scoreValueEl.className = 'score-value ' + scoreClass;
                scoreFillEl.style.width = score + '%';
                scoreFillEl.className = 'score-fill ' + scoreClass;
            } else {
                previewSectionEl.style.display = 'none';
            }
            
            // 状态
            const statusEl = document.getElementById('preview-status');
            const statusIconEl = document.getElementById('preview-status-icon');
            const statusTextEl = document.getElementById('preview-status-text');
            
            if (result.isValid && result.warnings.length === 0) {
                statusEl.className = 'preview-status valid';
                statusIconEl.textContent = '✅';
                statusTextEl.textContent = '数据格式正确，可以导入分析';
                document.getElementById('import-confirm-btn').disabled = false;
            } else if (result.isValid && result.warnings.length > 0) {
                statusEl.className = 'preview-status warning';
                statusIconEl.textContent = '⚠️';
                statusTextEl.textContent = '数据可导入，但存在警告: ' + result.warnings.join('; ');
                document.getElementById('import-confirm-btn').disabled = false;
            } else {
                statusEl.className = 'preview-status invalid';
                statusIconEl.textContent = '❌';
                statusTextEl.textContent = '数据异常: ' + result.issues.join('; ');
                document.getElementById('import-confirm-btn').disabled = true;
            }
        }
        
        // 全局变量保存当前预览结果
        let currentPreviewResult = null;
        
        // 选择数据组
        function selectDataGroup(groupIndex, element) {
            if (!currentPreviewResult || !currentPreviewResult.dataGroups) return;
            
            // 更新选中状态
            const options = document.querySelectorAll('.data-group-option');
            options.forEach(opt => opt.classList.remove('selected'));
            element.classList.add('selected');
            element.querySelector('input[type="radio"]').checked = true;
            
            // 更新选中的数据组索引
            currentPreviewResult.selectedGroupIndex = groupIndex;
            
            // 获取选中组的关节索引
            const selectedGroup = currentPreviewResult.dataGroups[groupIndex];
            
            // 重新进行骨架验证
            const newValidation = validateSkeletonData(currentPreviewResult.sampleDataRow, selectedGroup.joints);
            currentPreviewResult.skeletonValidation = newValidation;
            
            // 更新检测结果
            if (currentPreviewResult.detected) {
                currentPreviewResult.detected.skeletonJoints = selectedGroup.joints;
            }
            
            // 重新绘制骨架预览
            drawSkeletonPreview(currentPreviewResult.sampleDataRow, selectedGroup.joints, newValidation);
            
            // 更新骨架指标显示
            updateSkeletonMetrics(newValidation);
            
            // 更新质量评分
            updateQualityScore(newValidation.score);
        }
        
        // 更新骨架指标显示
        function updateSkeletonMetrics(validation) {
            const heightEl = document.getElementById('metric-height');
            const shoulderEl = document.getElementById('metric-shoulder');
            const armEl = document.getElementById('metric-arm');
            const legEl = document.getElementById('metric-leg');
            
            if (validation.height !== null) {
                heightEl.textContent = validation.height.toFixed(2) + 'm';
                heightEl.className = 'metric-value ' + 
                    (validation.height >= 1.4 && validation.height <= 2.2 ? 'normal' : 
                     (validation.height >= 1.2 && validation.height <= 2.5 ? 'warning' : 'error'));
            } else {
                heightEl.textContent = '--';
                heightEl.className = 'metric-value';
            }
            
            if (validation.shoulderWidth !== null) {
                shoulderEl.textContent = validation.shoulderWidth.toFixed(2) + 'm';
                shoulderEl.className = 'metric-value ' + 
                    (validation.shoulderWidth >= 0.25 && validation.shoulderWidth <= 0.6 ? 'normal' : 'warning');
            } else {
                shoulderEl.textContent = '--';
                shoulderEl.className = 'metric-value';
            }
            
            if (validation.armLength !== null) {
                armEl.textContent = validation.armLength.toFixed(2) + 'm';
                armEl.className = 'metric-value ' + 
                    (validation.armLength >= 0.4 && validation.armLength <= 0.9 ? 'normal' : 'warning');
            } else {
                armEl.textContent = '--';
                armEl.className = 'metric-value';
            }
            
            if (validation.legLength !== null) {
                legEl.textContent = validation.legLength.toFixed(2) + 'm';
                legEl.className = 'metric-value ' + 
                    (validation.legLength >= 0.6 && validation.legLength <= 1.2 ? 'normal' : 'warning');
            } else {
                legEl.textContent = '--';
                legEl.className = 'metric-value';
            }
        }
        
        // 更新质量评分
        function updateQualityScore(score) {
            const scoreValueEl = document.getElementById('score-value');
            const scoreFillEl = document.getElementById('score-fill');
            
            let scoreClass = 'error';
            let scoreText = '异常';
            if (score >= 80) {
                scoreClass = 'excellent';
                scoreText = '优秀';
            } else if (score >= 60) {
                scoreClass = 'good';
                scoreText = '良好';
            } else if (score >= 40) {
                scoreClass = 'warning';
                scoreText = '警告';
            }
            
            scoreValueEl.textContent = `${score}分 (${scoreText})`;
            scoreValueEl.className = 'score-value ' + scoreClass;
            scoreFillEl.style.width = score + '%';
            scoreFillEl.className = 'score-fill ' + scoreClass;
        }
        
        // 格式化文件大小
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }
        
        // 移除选中的文件
        function removeSelectedFile() {
            selectedFile = null;
            document.getElementById('import-drop-zone').style.display = 'block';
            document.getElementById('import-file-selected').classList.remove('show');
            document.getElementById('import-preview').classList.remove('show');
            document.getElementById('import-confirm-btn').disabled = true;
        }
        
        // 开始导入
        async function startImport() {
            if (!selectedFile) return;
            
            document.getElementById('import-progress').classList.add('show');
            document.getElementById('import-confirm-btn').disabled = true;
            document.getElementById('import-cancel-btn').disabled = true;
            
            try {
                const content = await selectedFile.text();
                const data = await processImportedFile(content, selectedFile.name);
                
                // 加载数据到全局变量
                await loadDataFromObject(data);
                
                // 更新标题
                document.getElementById('data-subtitle').textContent = 
                    `${data.athlete} - ${data.event} 投掷动作生物力学分析`;
                
                closeImportModal();
                
            } catch (error) {
                alert('导入失败: ' + error.message);
                document.getElementById('import-progress').classList.remove('show');
                document.getElementById('import-confirm-btn').disabled = false;
            }
            
            document.getElementById('import-cancel-btn').disabled = false;
        }
        
        // 初始化导入功能
        function initImportFeature() {
            const importBtn = document.getElementById('import-btn');
            const clearBtn = document.getElementById('clear-btn');
            const modal = document.getElementById('import-modal');
            const closeBtn = document.getElementById('import-modal-close');
            const dropZone = document.getElementById('import-drop-zone');
            const fileInput = document.getElementById('file-input');
            
            // 绑定清除按钮
            clearBtn.addEventListener('click', clearAllData);
            const removeBtn = document.getElementById('remove-file-btn');
            const cancelBtn = document.getElementById('import-cancel-btn');
            const confirmBtn = document.getElementById('import-confirm-btn');
            
            importBtn.addEventListener('click', openImportModal);
            closeBtn.addEventListener('click', closeImportModal);
            cancelBtn.addEventListener('click', closeImportModal);
            confirmBtn.addEventListener('click', startImport);
            removeBtn.addEventListener('click', removeSelectedFile);
            
            // 点击弹窗外部关闭
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeImportModal();
            });
            
            // 点击拖放区域触发文件选择
            dropZone.addEventListener('click', () => fileInput.click());
            
            // 文件选择
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileSelect(e.target.files[0]);
                }
            });
            
            // 拖放功能
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                if (e.dataTransfer.files.length > 0) {
                    handleFileSelect(e.dataTransfer.files[0]);
                }
            });
        }
        
        // 清除现有可视化
        function clearVisualization() {
            // 清除3D场景中的对象
            
            // 清除轨迹组（包含铁饼轨迹线和散点）
            if (trajectoryGroup) {
                scene.remove(trajectoryGroup);
                trajectoryGroup = null;
            }
            
            // 清除discusLine引用
            if (discusLine) {
                discusLine = null;
            }
            
            // 清除范围轨迹线
            if (rangeTrajectoryLine) {
                rangeTrajectoryLine = null;
            }
            
            // 清除重心轨迹
            if (comLine) {
                scene.remove(comLine);
                comLine = null;
            }
            
            // 清除释放点标记（包含 star 和 sphere 两个对象）
            if (releaseMarker) {
                if (releaseMarker.star) scene.remove(releaseMarker.star);
                if (releaseMarker.sphere) scene.remove(releaseMarker.sphere);
                releaseMarker = null;
            }
            
            // 清除当前点标记
            if (currentPointMarker) {
                scene.remove(currentPointMarker);
                currentPointMarker = null;
            }
            
            // 清除骨架
            if (skeletonGroup) {
                scene.remove(skeletonGroup);
                skeletonGroup = null;
            }
            
            // 清除角度可视化
            clearAllAngleVisuals();
            if (angleVisualsGroup) {
                scene.remove(angleVisualsGroup);
                angleVisualsGroup = null;
            }
            
            // 停止播放
            if (isPlaying) {
                isPlaying = false;
                if (playInterval) {
                    clearInterval(playInterval);
                    playInterval = null;
                }
            }
            
            // 重置范围裁剪状态
            rangeClipEnabled = false;
            const rangeBtn = document.getElementById('range-trajectory-btn');
            if (rangeBtn) rangeBtn.classList.remove('active');
            
            // 清除时间轴上的释放点标记
            const timelineMarkers = document.getElementById('timeline-markers');
            if (timelineMarkers) {
                const markers = timelineMarkers.querySelectorAll('.timeline-marker');
                markers.forEach(marker => marker.remove());
            }
            
            // 重置当前索引
            currentIndex = 0;
            
            // 重置索引
            currentIndex = 0;
        }
        
        // 清除所有数据并重置页面
        function clearAllData() {
            if (!discusData) {
                alert('当前没有数据需要清除');
                return;
            }
            
            if (!confirm('确定要清除当前的动捕数据吗？')) {
                return;
            }
            
            // 清除可视化
            clearVisualization();
            
            // 清除全局数据
            discusData = null;
            comData = null;
            skeletonData = null;
            rotationData = null;
            jointSpeedsData = null;
            releasePoint = null;
            biomechanics = null;
            autoPhases = [];
            manualPhases = [];
            currentPhases = [];
            
            // 重置UI显示
            document.getElementById('data-subtitle').textContent = '点击"导入数据"按钮开始分析';
            document.getElementById('release-speed').textContent = '--';
            document.getElementById('max-speed').textContent = '--';
            document.getElementById('current-time').textContent = '0.00';
            document.getElementById('total-time').textContent = '0.00';
            document.getElementById('start-frame').value = '0';
            document.getElementById('end-frame').value = '100';
            
            // 重置当前点显示
            document.getElementById('cur-x').textContent = '--';
            document.getElementById('cur-y').textContent = '--';
            document.getElementById('cur-z').textContent = '--';
            document.getElementById('cur-speed').textContent = '--';
            document.getElementById('cur-frame').textContent = '0';
            document.getElementById('total-frames').textContent = '0';
            
            // 重置出手参数
            document.getElementById('m-release-vel').textContent = '--';
            document.getElementById('m-release-height').textContent = '--';
            document.getElementById('m-release-angle').textContent = '--';
            document.getElementById('m-max-speed').textContent = '--';
            document.getElementById('m-time').textContent = '--';
            document.getElementById('m-trajectory').textContent = '--';
            document.getElementById('m-pos-x').textContent = '--';
            document.getElementById('m-pos-y').textContent = '--';
            document.getElementById('m-pos-z').textContent = '--';
            
            // 清除图表
            const speedCanvas = document.getElementById('speed-canvas');
            if (speedCanvas) {
                const ctx = speedCanvas.getContext('2d');
                ctx.clearRect(0, 0, speedCanvas.width, speedCanvas.height);
            }
            
            const comCanvas = document.getElementById('com-canvas');
            if (comCanvas) {
                const ctx = comCanvas.getContext('2d');
                ctx.clearRect(0, 0, comCanvas.width, comCanvas.height);
            }
            
            const jointCanvas = document.getElementById('joint-canvas');
            if (jointCanvas) {
                const ctx = jointCanvas.getContext('2d');
                ctx.clearRect(0, 0, jointCanvas.width, jointCanvas.height);
            }
            
            // 重置时间轴滑块
            const slider = document.getElementById('timeline-slider');
            if (slider) slider.value = 0;
            
            // 重置范围指示器
            const startHandle = document.getElementById('range-start-handle');
            const endHandle = document.getElementById('range-end-handle');
            if (startHandle) startHandle.style.left = '0%';
            if (endHandle) endHandle.style.left = '100%';
            
            // 清除localStorage中的手动阶段
            localStorage.removeItem('discus_manual_phases');
            
            // 重置阶段面板
            const phaseList = document.getElementById('phase-list');
            if (phaseList) phaseList.innerHTML = '';
            
            // 隐藏清除按钮
            document.getElementById('clear-btn').style.display = 'none';
            
            // 重置导入相关状态
            selectedFile = null;
            currentPreviewResult = null;
            
            console.log('数据已清除');
        }
        
        // 从对象加载数据（用于导入功能）
        async function loadDataFromObject(data) {
            // 先清除现有可视化
            clearVisualization();
            
            // 设置全局变量
            discusData = data.discus;
            comData = data.com;
            skeletonData = data.skeleton;
            rotationData = data.rotation;
            jointSpeedsData = data.joint_speeds;
            releasePoint = data.release_point;
            biomechanics = data.biomechanics;
            autoPhases = data.auto_phases || [];
            
            // 更新运动员信息
            const athleteNameEl = document.getElementById('athlete-name');
            const eventNameEl = document.getElementById('event-name');
            if (athleteNameEl && data.athlete) {
                athleteNameEl.textContent = data.athlete;
            }
            if (eventNameEl && data.event) {
                eventNameEl.textContent = data.event;
            }
            
            // 创建可视化
            createDiscusTrajectory();
            createComTrajectory();
            createReleaseMarker();
            createCurrentPointMarker();
            createSkeleton();
            updateDataPanel();
            drawSpeedChart();
            drawComChart();
            initJointSelector();
            initTimeline();
            
            // 设置按钮初始状态
            document.getElementById('skeleton-btn').classList.add('active');
            document.getElementById('trajectory-btn').classList.add('active');
            
            // 初始化图表标签页
            initChartTabs();
            
            // 初始化阶段面板
            initPhasePanel();
            
            // 清除手动阶段（新数据）
            manualPhases = [];
            localStorage.removeItem('discus_manual_phases');
            
            // 显示清除按钮
            document.getElementById('clear-btn').style.display = 'flex';
            
            // 隐藏加载动画
            document.getElementById('loading').classList.add('hidden');
        }
        
        // 初始化
        function init() {
            initCollapsibleSections();
            initScene();
            initImportFeature();  // 初始化导入功能
            
            // 隐藏加载动画
            document.getElementById('loading').classList.add('hidden');
            
            animate();
            
            // 绑定视图切换按钮
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.addEventListener('click', () => setView(btn.dataset.view));
            });
            
            // 绑定骨架切换按钮
            document.getElementById('skeleton-btn').addEventListener('click', toggleSkeleton);
            
            // 绑定轨迹切换按钮
            document.getElementById('trajectory-btn').addEventListener('click', toggleTrajectory);
            
            // 绑定范围裁剪按钮
            document.getElementById('range-trajectory-btn').addEventListener('click', toggleRangeClip);
            
            // 绑定跳远场地控制按钮
            document.getElementById('circle-move-btn').addEventListener('click', toggleGizmo);
            document.getElementById('circle-save-btn').addEventListener('click', saveCirclePosition);
            document.getElementById('circle-reset-btn').addEventListener('click', resetCirclePosition);
            
            // 绑定场地类型选择器
            document.getElementById('field-type-select').addEventListener('change', (e) => {
                switchFieldType(e.target.value);
            });
        }
        
        // 启动
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
